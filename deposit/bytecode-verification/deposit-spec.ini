; contract: https://github.com/ethereum/eth2.0-specs/blob/d1fe8f16fd4449cbf766d4ef2484b0891c04be58/deposit_contract/contracts/validator_registration.v.py
; vyper: https://github.com/ethereum/vyper/releases/tag/v0.1.0-beta.12

[root]
k: #execute
; default
pc: 0 => _
word_stack: .WordStack => _
local_mem: .Map => _
gas: #symGas(G, 0, 0, .List, Cmem({SCHEDULE}, #symMem(0, .Set))) => _
memory_used: #symMem(0, .Set) => _
; no changes
call_data: _
log: _
refund: _
storage: _
orig_storage: _
balance: INIT_BALANCE
nonce: INIT_NONCE
code: {RUNTIME_CODE}
; ignore (potential) changes
output: _ => _
status_code: _ => _
; variables
comment:
schedule:       PETERSBURG
call_stack:     CALL_STACK
this:           THIS
msg_sender:     MSG_SENDER
call_value:     CALL_VALUE
call_depth:     CALL_DEPTH
coinbase:       COIN_BASE
active_accounts:
accounts:
requires:
    // conditions
    andBool #range(0 <= CALL_DEPTH < 1024)
    andBool #regularAddress({SCHEDULE}, THIS)
    // types
    andBool #rangeAddress(THIS)
    andBool #rangeAddress(MSG_SENDER)
    andBool #rangeUInt(256, CALL_VALUE)
;   andBool #rangeUInt(256, INIT_GAS)
    andBool #rangeUInt(256, INIT_BALANCE)
    andBool #rangeUInt(256, INIT_NONCE)
    andBool #rangeUInt(256, EXTRA_CALL_DATA_SIZE)
ensures:
attribute:
VYPER_GENERATED_BOUNDS:
    ; bounds - vyper generated
    [  32 := #buf(32, 1461501637330902918203684832716283019655932542976) ]
    [  64 := #buf(32, 170141183460469231731687303715884105727) ]
    [  96 := #buf(32, 115792089237316195423570985008687907853099843482180094807725896704197245534208) ]
    [ 128 := #buf(32, 1701411834604692317316873037158841057270000000000) ]
    [ 160 := #buf(32, 115792089237316195423570985006986496018665292348323691002298742950633129639936) ]
LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT:
    [ 352 := #buf(32, {RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64}) ]  /* return address */
    [ 320 := #buf(32, DEPOSIT_COUNT) ]  /* argument */
    [ 384 := #buf(32, Y8) ]             /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, X8) ]             /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, 8) ]              /* for-loop index */
    [ 480 := #buf(32, X7 &Int 255) ]    /* bitwise_and(x, 255) */
    [ 544 := #buf(32, Y8) ]             /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, 8) ]              /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]  /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT:
    [ 352 := #buf(32, {RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}) ]  /* return address */
    [ 320 := #buf(32, {DEPOSIT_AMOUNT}) ]   /* argument */
    [ 384 := #buf(32, YY8) ]                /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, XX8) ]                /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, 8) ]                  /* for-loop index */
    [ 480 := #buf(32, XX7 &Int 255) ]       /* bitwise_and(x, 255) */
    [ 544 := #buf(32, YY8) ]                /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, 8) ]                  /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]  /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
TO_LITTLE_ENDIAN_64_ZERO_PADDING:
    [ 800 := #buf(32, 32) ]             /* padding loop index */
    [ 744 <- 0 ]                        /* padding */
    [ 745 <- 0 ]
    [ 746 <- 0 ]
    [ 747 <- 0 ]
    [ 748 <- 0 ]
    [ 749 <- 0 ]
    [ 750 <- 0 ]
    [ 751 <- 0 ]
    [ 752 <- 0 ]
    [ 753 <- 0 ]
    [ 754 <- 0 ]
    [ 755 <- 0 ]
    [ 756 <- 0 ]
    [ 757 <- 0 ]
    [ 758 <- 0 ]
    [ 759 <- 0 ]
    [ 760 <- 0 ]
    [ 761 <- 0 ]
    [ 762 <- 0 ]
    [ 763 <- 0 ]
    [ 764 <- 0 ]
    [ 765 <- 0 ]
    [ 766 <- 0 ]
    [ 767 <- 0 ]
    [ 672 := #buf(32, 32) ]             /* ??? */
    [ 640 := #buf(32, 0) ]              /* ??? */
LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT:
    // let-bindings
    andBool X1 ==Int DEPOSIT_COUNT /Int 256
    andBool X2 ==Int X1            /Int 256
    andBool X3 ==Int X2            /Int 256
    andBool X4 ==Int X3            /Int 256
    andBool X5 ==Int X4            /Int 256
    andBool X6 ==Int X5            /Int 256
    andBool X7 ==Int X6            /Int 256
    andBool X8 ==Int X7            /Int 256
    //
    andBool Y1 ==Int          DEPOSIT_COUNT &Int 255
    andBool Y2 ==Int (Y1 *Int 256) +Int (X1 &Int 255)
    andBool Y3 ==Int (Y2 *Int 256) +Int (X2 &Int 255)
    andBool Y4 ==Int (Y3 *Int 256) +Int (X3 &Int 255)
    andBool Y5 ==Int (Y4 *Int 256) +Int (X4 &Int 255)
    andBool Y6 ==Int (Y5 *Int 256) +Int (X5 &Int 255)
    andBool Y7 ==Int (Y6 *Int 256) +Int (X6 &Int 255)
    andBool Y8 ==Int (Y7 *Int 256) +Int (X7 &Int 255)
LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT:
    // let-bindings
    andBool XX1 ==Int {DEPOSIT_AMOUNT} /Int 256
    andBool XX2 ==Int XX1              /Int 256
    andBool XX3 ==Int XX2              /Int 256
    andBool XX4 ==Int XX3              /Int 256
    andBool XX5 ==Int XX4              /Int 256
    andBool XX6 ==Int XX5              /Int 256
    andBool XX7 ==Int XX6              /Int 256
    andBool XX8 ==Int XX7              /Int 256
    //
    andBool YY1 ==Int         {DEPOSIT_AMOUNT} &Int 255
    andBool YY2 ==Int (YY1 *Int 256) +Int (XX1 &Int 255)
    andBool YY3 ==Int (YY2 *Int 256) +Int (XX2 &Int 255)
    andBool YY4 ==Int (YY3 *Int 256) +Int (XX3 &Int 255)
    andBool YY5 ==Int (YY4 *Int 256) +Int (XX4 &Int 255)
    andBool YY6 ==Int (YY5 *Int 256) +Int (XX5 &Int 255)
    andBool YY7 ==Int (YY6 *Int 256) +Int (XX6 &Int 255)
    andBool YY8 ==Int (YY7 *Int 256) +Int (XX7 &Int 255)

;
; __init__
;

; @public
; def __init__():
;     for i in range(DEPOSIT_CONTRACT_TREE_DEPTH - 1):
;         self.zero_hashes[i + 1] = sha256(concat(self.zero_hashes[i], self.zero_hashes[i]))

[init]
; for create
code: {INIT_CODE}
call_data: .WordStack
storage: .Map
orig_storage: .Map
; for constructor
WORD_STACK_INIT: 31 : 320 : .WordStack
LOCAL_MEM_INIT: .Map
    {VYPER_GENERATED_BOUNDS}
    [ 320 := #buf(32, 0) ]              /* i = 0 */

[init-init]
pc: 0 => 164
word_stack: .WordStack => {WORD_STACK_INIT}
local_mem: .Map => {LOCAL_MEM_INIT}
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
gas:         #symGas(G, 0 => 85, 0 => 85, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 352, .Set)

[init-loop0]
pc: 164 => 369
word_stack: {WORD_STACK_INIT} => 1 : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 384 := #buf(32, select(.Map, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))) ]    /* self.zero_hashes[0] */
    [ 416 := #buf(32, select(.Map, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))) ]    /* self.zero_hashes[0] */
    [ 352 := #buf(32, 64) ]                 /* size of sha256 */
    [ 192 := #buf(32, {ZERO_HASHES_1}) ]    /* sha256(384, 64) return */
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 320 := #buf(32, 1) ]                  /* i = 1 */
storage: .Map => .Map
    [ #hashedLocation({COMPILER}, {ZERO_HASHES}, 1) <- {ZERO_HASHES_1} ]
refund: _ => _
ZERO_HASHES_1: #sha256(#buf(32, 0) ++ #buf(32, 0))
gas:         #symGas(G, 0 => 21667, 0 => 21667, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(352 => 448, .Set)

[init-loop]
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 2) ]              /* zero_hashes storage index = 2 */
    [ 384 := #buf(32, ANON_1) ]         /* self.zero_hashes[i] */
    [ 416 := #buf(32, ANON_2) ]         /* self.zero_hashes[i] */
    [ 352 := #buf(32, 64) ]             /* size of sha256 */
    [ 320 := #buf(32, I) ]              /* i = i + 1 */
storage: M
+requires:
    // conditions
    andBool #range(0 <= I <= 31)
    // types
    andBool isStorage(M)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)

[init-loop-enter]
pc: 369
word_stack: (I => I +Int 1) : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 384 := #buf(32, select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, I))) ]  /* self.zero_hashes[i] */
    [ 416 := #buf(32, select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, I))) ]  /* self.zero_hashes[i] */
    [ 352 := #buf(32, 64) ]                 /* size of sha256 */
    [ 192 := #buf(32, {ZERO_HASHES_I+1}) ]  /* sha256(384, 64) return */
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 320 := #buf(32, I +Int 1) ]           /* i = i + 1 */
storage: M => M
    [ #hashedLocation({COMPILER}, {ZERO_HASHES}, I +Int 1) <- {ZERO_HASHES_I+1} ]
refund: _ => _
ZERO_HASHES_I: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, I))
ZERO_HASHES_I+1: #sha256(#buf(32, {ZERO_HASHES_I}) ++ #buf(32, {ZERO_HASHES_I}))
+requires:
    // conditions
    andBool I <Int 31
gas:         #symGas(G, 0 => 6689, 0 => 21689, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448, .Set)

[init-loop-exit]
k: #execute => #halt
pc: 369 => 4586
output: _ => #parseByteStack({RUNTIME_CODE})
word_stack: I : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 0 := #parseByteStack({RUNTIME_CODE}) ]
+requires:
    // conditions
    andBool I ==Int 31
gas:         #symGas(G, 0 => 462, 0 => 462, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448 => 4180, .Set)

;
; to_little_endian_64
;

[to_little_endian_64-trusted]
gas:         #symGas(G, LB => LB +Int 7530, UB => UB +Int 7530, GS, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(MU => maxInt(MU, 832), MUS)
attribute: [trusted, matching(#symGas,#symMem,Cmem)]

[to_little_endian_64]
k: #execute
pc: {PC_BEGIN} => {PC_END}
word_stack: {WORD_STACK_BEGIN} => {WORD_STACK_END}
local_mem: {LOCAL_MEM_BEGIN} => {LOCAL_MEM_END}
LOOP_BOUND: 8
SLICE_LENGTH: 8
PC_BEGIN:  155
PC_MIDDLE: 373
PC_END:    611
WORD_STACK_BEGIN:  RETURN_ADDR : VALUE                 : WS /* WS saves caller's local vars */
WORD_STACK_MIDDLE: {LOOP_BOUND} : 448                  : WS
WORD_STACK_END:    RETURN_ADDR : 32 : 8 : {RETURN_VAL} : WS
; RETURN_VAL: selectRange({LOCAL_MEM_END}, 736, 32)
RETURN_VAL: #asWord(#bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0))
LOCAL_MEM_BEGIN:  MEM
LOCAL_MEM_MIDDLE: {LOCAL_MEM_BEGIN}  {LOCAL_MEM_UPDATE_FROM_BEGIN_TO_MIDDLE}
LOCAL_MEM_END:    {LOCAL_MEM_MIDDLE} {LOCAL_MEM_UPDATE_FROM_MIDDLE_TO_END}
LOCAL_MEM_UPDATE_FROM_BEGIN_TO_MIDDLE:
    [ 352 := #buf(32, RETURN_ADDR) ]
    [ 320 := #buf(32, VALUE) ]
    [ 384 := #buf(32, Y8) ]             /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, X8) ]             /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, {LOOP_BOUND}) ]   /* for-loop index */
    [ 480 := #buf(32, X7 &Int 255) ]    /* bitwise_and(x, 255) */
LOCAL_MEM_UPDATE_FROM_MIDDLE_TO_END:
    [ 544 := #buf(32, Y8) ]             /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, {SLICE_LENGTH}) ] /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, {SLICE_LENGTH}) ++ #bufSeg(#buf(32, Y8), 24, {SLICE_LENGTH}) ]    /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
+requires:
    // conditions
    andBool #range(0 <= #sizeWordStack(WS) <= 1000) // NOTE: rough bound
    andBool #rangeUInt(256, RETURN_ADDR)
    andBool #rangeUInt(256, VALUE)
    // let-bindings
    andBool X1 ==Int VALUE /Int 256
    andBool X2 ==Int X1    /Int 256
    andBool X3 ==Int X2    /Int 256
    andBool X4 ==Int X3    /Int 256
    andBool X5 ==Int X4    /Int 256
    andBool X6 ==Int X5    /Int 256
    andBool X7 ==Int X6    /Int 256
    andBool X8 ==Int X7    /Int 256
    //
    andBool Y1 ==Int                  VALUE &Int 255
    andBool Y2 ==Int (Y1 *Int 256) +Int (X1 &Int 255)
    andBool Y3 ==Int (Y2 *Int 256) +Int (X2 &Int 255)
    andBool Y4 ==Int (Y3 *Int 256) +Int (X3 &Int 255)
    andBool Y5 ==Int (Y4 *Int 256) +Int (X4 &Int 255)
    andBool Y6 ==Int (Y5 *Int 256) +Int (X5 &Int 255)
    andBool Y7 ==Int (Y6 *Int 256) +Int (X6 &Int 255)
    andBool Y8 ==Int (Y7 *Int 256) +Int (X7 &Int 255)
gas:         #symGas(G, 0 => 7530, 0 => 7530, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 832, .Set)

[to_little_endian_64-forloop]
pc: {PC_BEGIN} => {PC_MIDDLE}
word_stack: {WORD_STACK_BEGIN} => {WORD_STACK_MIDDLE}
local_mem: {LOCAL_MEM_BEGIN} => {LOCAL_MEM_MIDDLE}
;   ; save call stack args
;   [ 352 := #buf(32, RETURN_ADDR) ]
;   [ 320 := #buf(32, VALUE) ]
;   ; init locals
;   [ 384 := #buf(32, 0) ]                  /* y: uint256 = 0 */
;   [ 416 := #buf(32, VALUE) ]              /* x: uint256 = value */
;   [ 448 := #buf(32, 0) ]                  /* init for-loop index */
;   ; loop body (pc: 189 <-> 372)
;   [ 384 := #buf(32, 0) ]                  /* y = shift(y, 8) */ /* y << 8 */
;   [ 480 := #buf(32, VALUE &Int 255) ]     /* bitwise_and(x, 255) */
;   [ 384 := #buf(32, VALUE &Int 255) ]     /* y = y + bitwise_and(x, 255) */
;   [ 416 := #buf(32, VALUE /Int 256) ]     /* x = shift(x, -8) */ /* x >> 8 */
;   [ 448 := #buf(32, 1) ]                  /* increase for-loop index */
;   ; ... repeat loop body ...
gas: #symGas(G, 0, 0, .List, Cmem({SCHEDULE}, #symMem(0, .Set))) => _
memory_used: #symMem(0, .Set) => _

[to_little_endian_64-return]
pc: {PC_MIDDLE} => {PC_END}
word_stack: {WORD_STACK_MIDDLE} => {WORD_STACK_END}
local_mem: {LOCAL_MEM_MIDDLE} => {LOCAL_MEM_END}
;   [ 544 := #buf(32, Y8) ]                 /* memcpy 544 <- 384 */
;   [ 536 := #buf(32, 8) ]                  /* slice by overwrite */
;   [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8)) ]         /* prepareing for return value*/
;
;   [ 800 := #buf(32, 8) ]
;   [ 744 <- 0 ]
;   [ 800 := #buf(32, 9) ]
;   [ 745 <- 0 ]
;   ...
;   [ 767 <- 0 ]                            /* padding */
;   [ 800 := #buf(32, 32) ]                 /* padding loop index */
;
;   [ 672 := #buf(32, 32) ]
;   [ 640 := #buf(32, 96) ]
;   [ 640 := #buf(32, 64) ]
;   [ 640 := #buf(32, 32) ]
;   [ 640 := #buf(32, 0) ]
gas: #symGas(G, 0, 0, .List, Cmem({SCHEDULE}, #symMem(0, .Set))) => _
memory_used: #symMem(0, .Set) => _

;
; get_deposit_root
;

[get_deposit_root]
; The term `#buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)` models certain extra call-data added accidently or intentionally.
; This ensures that the function works correctly even in such a case.
call_data: #abiCallData("get_deposit_root", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
storage: M
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
PC_LOOPENTER: 672
PC_LOOPHEAD: 943
PC_END: 1269
WORD_STACK_INIT: 32 : 416 : .WordStack
LOCAL_MEM_BEGIN: .Map
    ; function hash
    [  28 := 197 : 242 : 137 : 47 : #take(28, #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)) ]
    {VYPER_GENERATED_BOUNDS}
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; locals
    [ 320 := #buf(32, 0) ]              /* zero_bytes32: bytes32 = 0x0 */
    [ 352 := #buf(32, 0) ]              /* node: bytes32 = zero_bytes32 */
    [ 384 := #buf(32, DEPOSIT_COUNT) ]  /* size: uint256 = self.deposit_count */
    [ 416 := #buf(32, 0) ]              /* height = 0 */

[get_deposit_root-init]
pc: 0 => {PC_LOOPENTER}
word_stack: .WordStack => {WORD_STACK_INIT}
local_mem: .Map => {LOCAL_MEM_INIT}
; gas usage = 417 = 375 + ( 42 = 3*n + n^2 / 512 where n = 14 = 448 / 32 )
gas:         #symGas(G, 0 => 375, 0 => 375, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 448, .Set)

[get_deposit_root-loop0]
pc: {PC_LOOPENTER} => {PC_LOOPHEAD}
word_stack: {WORD_STACK_INIT} => 1 : {WORD_STACK_INIT}

[get_deposit_root-loop0-then]
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 0) ]                              /* branch storage index = 0 */
    [ 608 := #buf(32, {BRANCH_0}) ]                     /* branch[0] */
    [ 640 := #buf(32, 0) ]                              /* node */
    [ 576 := #buf(32, 64) ]                             /* size of sha256 input */
    [ 192 := #buf(32, {NODE_1}) ]                       /* sha256 return value via sha256(608, 64) */
    [ 352 := #buf(32, {NODE_1}) ]                       /* update node = sha256(branch[0], node) */
    [ 384 := #buf(32, DEPOSIT_COUNT /Int 2) ]           /* update size */
    [ 416 := #buf(32, 1) ]                              /* update height */
BRANCH_0: select(M, #hashedLocation({COMPILER}, {BRANCH}, 0))
NODE_1: #sha256(#buf(32, {BRANCH_0}) ++ #buf(32, 0))
+requires:
    // conditions
    andBool DEPOSIT_COUNT &Int 1 ==Int 1
; gas usage = 1766 = 1703 + ( 63 = 3*n + n^2 / 512 where n = 21 = 672 / 32 )
gas:         #symGas(G, 375 => 1703, 375 => 1703, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448 => 672, .Set)

[get_deposit_root-loop0-else]
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 480 := #buf(32, 0) ]                              /* node */
    [ 192 := #buf(32, 2) ]                              /* zero_hashes storage index = 2 */
    [ 512 := #buf(32, {ZERO_HASHES_0}) ]                /* zero_hashes[0] */
    [ 448 := #buf(32, 64) ]                             /* size of sha256 input */
    [ 192 := #buf(32, {NODE_1}) ]                       /* sha256 return value via sha256(480, 64) */
    [ 352 := #buf(32, {NODE_1}) ]                       /* update node = sha256(node, zero_hashes[0]) */
    [ 384 := #buf(32, DEPOSIT_COUNT /Int 2) ]           /* update size */
    [ 416 := #buf(32, 1) ]                              /* update height */
ZERO_HASHES_0: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))
NODE_1: #sha256(#buf(32, 0) ++ #buf(32, {ZERO_HASHES_0}))
+requires:
    // conditions
    andBool DEPOSIT_COUNT &Int 1 =/=Int 1
; gas usage = 1744 = 1693 + ( 51 = 3*n + n^2 / 512 where n = 17 = 544 / 32 )
gas:         #symGas(G, 375 => 1693, 375 => 1693, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448 => 544, .Set)

[get_deposit_root-loop]
; MEMORY_USED_LOOPHEAD: 17 or 21
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_BEGIN}
    ; locals
    [ 320 := #buf(32, 0) ]          /* zero_bytes32: bytes32 = 0x0 */
    [ 352 := #buf(32, NODE) ]       /* node: bytes32 */
    [ 384 := #buf(32, SIZE) ]       /* size: uint256 */
    [ 416 := #buf(32, HEIGHT) ]     /* height */
    ; garbages
    [ 192 := #buf(32, ANON_1) ]     /* sha256 return value */
    // for if-then branch
    [ 576 := #buf(32, ANON_2) ]     /* size of sha256 input */
    [ 608 := #buf(32, ANON_3) ]     /* branch[height] */
    [ 640 := #buf(32, ANON_4) ]     /* node */
    // for if-else branch
    [ 448 := #buf(32, ANON_5) ]     /* size of sha256 input */
    [ 480 := #buf(32, ANON_6) ]     /* node */
    [ 512 := #buf(32, ANON_7) ]     /* zero_hashes[height] */
+requires:
    // conditions
    andBool #range(0 <= HEIGHT <= 32)
    // types
    andBool #rangeUInt(256, NODE)
    andBool #rangeUInt(256, SIZE)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)
    andBool #rangeUInt(256, ANON_3)
    andBool #rangeUInt(256, ANON_4)
    andBool #rangeUInt(256, ANON_5)
    andBool #rangeUInt(256, ANON_6)
    andBool #rangeUInt(256, ANON_7)

[get_deposit_root-loop-body]
pc: {PC_LOOPHEAD}
word_stack: (HEIGHT => HEIGHT +Int 1) : {WORD_STACK_INIT}
+requires:
    // conditions
    andBool HEIGHT <Int 32

[get_deposit_root-loop-body-then]
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 192 := #buf(32, 0) ]                      /* branch storage index = 0 */
    [ 608 := #buf(32, {BRANCH_HEIGHT}) ]        /* branch[height] */
    [ 640 := #buf(32, NODE) ]                   /* node */
    [ 576 := #buf(32, 64) ]                     /* size of sha256 input */
    [ 192 := #buf(32, {NODE_NEW}) ]             /* sha256 return value */
    [ 352 := #buf(32, {NODE_NEW}) ]             /* update node */
    [ 384 := #buf(32, SIZE /Int 2) ]            /* update size */
    [ 416 := #buf(32, HEIGHT +Int 1) ]          /* update height */
BRANCH_HEIGHT: select(M, #hashedLocation({COMPILER}, {BRANCH}, HEIGHT))
NODE_NEW: #sha256(#buf(32, {BRANCH_HEIGHT}) ++ #buf(32, NODE))
+requires:
    // conditions
    andBool SIZE &Int 1 ==Int 1
gas:         #symGas(G, 0 => 1350, 0 => 1350, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(672, .Set)

[get_deposit_root-loop-body-else]
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 480 := #buf(32, NODE) ]                   /* node */
    [ 192 := #buf(32, 2) ]                      /* zero_hashes storage index = 2 */
    [ 512 := #buf(32, {ZERO_HASHES_HEIGHT}) ]   /* zero_hashes[height] */
    [ 448 := #buf(32, 64) ]                     /* size of sha256 input */
    [ 192 := #buf(32, {NODE_NEW}) ]             /* sha256 return value via sha256(480, 64) */
    [ 352 := #buf(32, {NODE_NEW}) ]             /* update node = sha256(node, zero_hashes[height]) */
    [ 384 := #buf(32, SIZE /Int 2) ]            /* update size = size / 2 */
    [ 416 := #buf(32, HEIGHT +Int 1) ]          /* update height = height + 1 */
ZERO_HASHES_HEIGHT: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, HEIGHT))
NODE_NEW: #sha256(#buf(32, NODE) ++ #buf(32, {ZERO_HASHES_HEIGHT}))
+requires:
    // conditions
    andBool SIZE &Int 1 =/=Int 1
gas:         #symGas(G, 0 => 1340, 0 => 1340, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(672, .Set)

[get_deposit_root-loop-exit]
k: #execute => #halt
pc: {PC_LOOPHEAD} => {PC_END}
RETURN_VAL: #sha256(#buf(32, NODE) ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0))
output: _ => #buf(32, {RETURN_VAL})
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    ; preparing for calling to_little_endian_64
    [ 1152 := #buf(32, NODE) ]
    [  736 := #buf(32, 2154246793) ]            /* 0x80673289 */ /* ??? */
    [  768 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64 (pc: 1013 -> [155 -> ... -> 628] -> 1014)
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; finish
    [  864 := #buf(32, 8) ]
    [  960 := #buf(32, 0) ]
    [  896 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]
    [  960 := #buf(32, 32) ]
    [  384 := #buf(32, SIZE) ]                  /* restore size: uint256 */
    [  352 := #buf(32, NODE) ]                  /* restore node: bytes32 */
    [  320 := #buf(32, 0) ]                     /* restore zero_bytes32: bytes32 */
    [ 1184 := #bufSeg(#buf(32, Y8), 24, 8) ]    /* self.to_little_endian_64(self.deposit_count) */  /* via memcpy(1152 <- 864,  8) */
    [ 1024 := #buf(32, 0) ]                     /* zero_bytes32 */                                  /* via memcpy( 992 <- 320, 32) */
    [  992 := #buf(32, 24) ]                    /* slice len */
    [ 1192 := #buf(24, 0) ]                     /* slice(zero_bytes32, start=0, len=24) */          /* via memcpy(1160 <- 992, 24) */
    [ 1120 := #buf(32, 64) ]
    [  192 := #buf(32, {RETURN_VAL}) ]          /* via sha256(1120, 64) */
    [    0 := #buf(32, {RETURN_VAL}) ]          /* return sha256(concat(node, self.to_little_endian_64(self.deposit_count), slice(zero_bytes32, start=0, len=24))) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64: 1014
+requires:
    // conditions
    andBool HEIGHT ==Int 32
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
gas:         #symGas(G, 0 => 11362, 0 => 11362, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(672 => 1216, .Set)

;
; get_deposit_count
;

[get_deposit_count]
; The term `#buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)` models certain extra call-data added accidently or intentionally.
; This ensures that the function works correctly even in such a case.
call_data: #abiCallData("get_deposit_count", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
storage: M
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
LOCAL_MEM_BEGIN: .Map
    ; function hash
    [  28 := 98 : 31 : 209 : 48 : #take(28, #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)) ]
;   [  28 <-  98 ]
;   [  29 <-  31 ]
;   [  30 <- 209 ]
;   [  31 <-  48 ]
    {VYPER_GENERATED_BOUNDS}
k: #execute => #halt
pc: 0 => 1527
output: _ => #buf(32, 32) ++ #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0)
           ; 608             640            672                             680         704
word_stack: .WordStack
local_mem: .Map => {LOCAL_MEM_BEGIN}
    ; before call
    [ 320 := #buf(32, 2154246793) ]     /* 0x80673289 */ /* ??? */
    [ 352 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; after call
    [ 448 := #buf(32, 8) ]
    [ 544 := #buf(32, 0) ]
    [ 480 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]  /* return value from to_little_endian_64 */
    [ 544 := #buf(32, 32) ]
    [ 640 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]  /* memcpy(640 <- 448, 40) */
    [ 736 := #buf(32, 32) ]                                 /* zero padding loop index */
    [ 680 <- 0 ]                                            /* zero padding */
    [ 681 <- 0 ]
    [ 682 <- 0 ]
    [ 683 <- 0 ]
    [ 684 <- 0 ]
    [ 685 <- 0 ]
    [ 686 <- 0 ]
    [ 687 <- 0 ]
    [ 688 <- 0 ]
    [ 689 <- 0 ]
    [ 690 <- 0 ]
    [ 691 <- 0 ]
    [ 692 <- 0 ]
    [ 693 <- 0 ]
    [ 694 <- 0 ]
    [ 695 <- 0 ]
    [ 696 <- 0 ]
    [ 697 <- 0 ]
    [ 698 <- 0 ]
    [ 699 <- 0 ]
    [ 700 <- 0 ]
    [ 701 <- 0 ]
    [ 702 <- 0 ]
    [ 703 <- 0 ]
    [ 608 := #buf(32, 32) ]                                 /* return(608, 96) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64: 1326
gas:         #symGas(G, 0 => 11346, 0 => 11346, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 832, .Set)

;
; deposit
;

; TODO: explore when call_data is not well-formed, e.g., some arguments are not provided

[deposit]
; #buf(32, 96) ++ #buf(32, 192) ++ #buf(32, 256)        // header
; ++ #buf(32, 48) ++ #buf(48, PUBKEY) ++ #buf(16, 0)    // pubkey + zero-padding
; ++ #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS)   // withdrawal_credentials
; ++ #buf(32, 96) ++ #buf(96, SIGNATURE)                // signature
call_data: #abiCallData("deposit", (
            #bytes(#buf({PUBKEY_LENGTH},                 PUBKEY)),
            #bytes(#buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)),
            #bytes(#buf({SIGNATURE_LENGTH},              SIGNATURE)),
            #bytes32(DEPOSIT_DATA_ROOT) ))
storage: M
+requires:
    // ranges
    andBool #range(0 <= PUBKEY                 < 2 ^Int ({PUBKEY_LENGTH}                 *Int 8))
    andBool #range(0 <= WITHDRAWAL_CREDENTIALS < 2 ^Int ({WITHDRAWAL_CREDENTIALS_LENGTH} *Int 8))
    andBool #range(0 <= SIGNATURE              < 2 ^Int ({SIGNATURE_LENGTH}              *Int 8))
    andBool #rangeUInt(256, DEPOSIT_DATA_ROOT)
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}
    // conditions
    andBool DEPOSIT_COUNT <Int {MAX_DEPOSIT_COUNT}
    andBool CALL_VALUE /Int {GWEI_IN_WEI} >=Int {MIN_DEPOSIT_AMOUNT}
PUBKEY_LENGTH:                 48
WITHDRAWAL_CREDENTIALS_LENGTH: 32
SIGNATURE_LENGTH:              96
MAX_DEPOSIT_COUNT:  4294967295
GWEI_IN_WEI:        1000000000
MIN_DEPOSIT_AMOUNT: 1000000000
DEPOSIT_AMOUNT: (CALL_VALUE /Int {GWEI_IN_WEI})
LOCAL_MEM_BEGIN: .Map
    {LOCAL_MEM_DEPOSIT_FUNCTION_HASH}
    {VYPER_GENERATED_BOUNDS}
LOCAL_MEM_DEPOSIT_FUNCTION_HASH:
    ; function hash
    [  28 <-  34 ]
    [  29 <- 137 ]
    [  30 <-  81 ]
    [  31 <-  24 ]
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; load calldata
    [  320 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* calldatacopy(416, 100,  80) */
    [  448 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /* calldatacopy(544, 196,  64) */
    [  544 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /* calldatacopy(640, 260, 128) */
    [  736 := #buf(32, {GWEI_IN_WEI}) ]                             /* 1 gwei = 10^9 wei */
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /* deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei") */
LOCAL_MEM_SUBCALL_1: {LOCAL_MEM_INIT}
    ; before call
    [  864 := #buf(32, 288) ]                                       /* memcpy loop index */
    [  896 := #buf(32, 2154246793) ]                                /* ??? */
    [  928 := #buf(32, {DEPOSIT_AMOUNT}) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}
    ; after call
    [ 1024 := #buf(32, 8) ]
    [ 1120 := #buf(32, 0) ]
    [ 1056 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [ 1120 := #buf(32, 32) ]
    ; restore stack
    [  832 := #buf(32, 0) ]
    [  800 := #buf(32, 0) ]
    [  768 := #buf(32, 0) ]
    [  736 := #buf(32, {GWEI_IN_WEI}) ]
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  672 := #buf(32, 0) ]
    [  640 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]
    [  608 := #bufSeg(#buf(96, SIGNATURE), 32, 32) ]
    [  576 := #bufSeg(#buf(96, SIGNATURE),  0, 32) ]
    [  544 := #buf(32, 96) ]
    [  512 := #buf(32, 0) ]
    [  480 := #buf(32, WITHDRAWAL_CREDENTIALS) ]
    [  448 := #buf(32, 32) ]
    [  416 := #buf(32, 0) ]
    [  384 := #bufSeg(#buf(48, PUBKEY), 32, 16) ++ #buf(16, 0) ]
    [  352 := #bufSeg(#buf(48, PUBKEY),  0, 32) ]
    [  320 := #buf(32, 48) ]
    ; copy result
    [  768 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]    /* memcpy(768 <- 1024, 40) */ /* amount: bytes[8] = self.to_little_endian_64(deposit_amount) */
LOCAL_MEM_SUBCALL_2: {LOCAL_MEM_SUBCALL_1}
    ; before call
    [ 1152 := #buf(32, 288) ]                                       /* memcpy loop index */
    [ 1184 := #buf(32, 2154246793) ]                                /* ??? */
    [ 1216 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; after call
    [ 1312 := #buf(32, 8) ]
    [ 1408 := #buf(32, 0) ]
    [ 1344 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]
    [ 1408 := #buf(32, 32) ]
    ; restore stack
    [ 1120 := #buf(32, 32) ]
    [ 1088 := #buf(32, 0) ]
    [ 1056 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [ 1024 := #buf(32, 8) ]
    [  992 := #buf(32, 0) ]
    [  960 := #buf(32, 0) ]
    [  928 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  896 := #buf(32, 2154246793) ]
    [  864 := #buf(32, 288) ]
    [  832 := #buf(32, 0) ]
    [  800 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [  768 := #buf(32, 8) ]
    [  736 := #buf(32, {GWEI_IN_WEI}) ]
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  672 := #buf(32, 0) ]
    [  640 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]
    [  608 := #bufSeg(#buf(96, SIGNATURE), 32, 32) ]
    [  576 := #bufSeg(#buf(96, SIGNATURE),  0, 32) ]
    [  544 := #buf(32, 96) ]
    [  512 := #buf(32, 0) ]
    [  480 := #buf(32, WITHDRAWAL_CREDENTIALS) ]
    [  448 := #buf(32, 32) ]
    [  416 := #buf(32, 0) ]
    [  384 := #bufSeg(#buf(48, PUBKEY), 32, 16) ++ #buf(16, 0) ]
    [  352 := #bufSeg(#buf(48, PUBKEY),  0, 32) ]
    [  320 := #buf(32, 48) ]
    ; copy result
    [ 1440 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ] /* memcpy(1440 <- 1312, 40) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT: 1830
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64:                2052
LOCAL_MEM_LOG: {LOCAL_MEM_SUBCALL_2}
    [ 1568 := #buf(32, 160) ]                                       /* offset pointer */
    [ 1632 := #buf(32, 160) ]                                       /* offset to pubkey */
    [ 1792 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* pubkey */ /* memcpy(1792 <- 320, 80) */
    [ 1536 := #buf(32, 64) ]                                        /* padding index */
    [ 1872 <- 0 ]
    [ 1873 <- 0 ]
    [ 1874 <- 0 ]
    [ 1875 <- 0 ]
    [ 1876 <- 0 ]
    [ 1877 <- 0 ]
    [ 1878 <- 0 ]
    [ 1879 <- 0 ]
    [ 1880 <- 0 ]
    [ 1881 <- 0 ]
    [ 1882 <- 0 ]
    [ 1883 <- 0 ]
    [ 1884 <- 0 ]
    [ 1885 <- 0 ]
    [ 1886 <- 0 ]
    [ 1887 <- 0 ]
    [ 1568 := #buf(32, 256) ]
    [ 1664 := #buf(32, 256) ]                                       /* offset to withdrawal_credentials */
    [ 1888 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /* withdrawal_credentials */ /* memcpy(1888 <- 448, 64) */
    [ 1536 := #buf(32, 32) ]                                        /* padding index */
    [ 1568 := #buf(32, 320) ]
    [ 1696 := #buf(32, 320) ]                                       /* offset to amount */
    [ 1952 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]        /* amount */ /* memcpy(1952 <- 768, 40) */
    [ 1536 := #buf(32, 32) ]                                        /* padding index */
    [ 1992 <- 0 ]
    [ 1993 <- 0 ]
    [ 1994 <- 0 ]
    [ 1995 <- 0 ]
    [ 1996 <- 0 ]
    [ 1997 <- 0 ]
    [ 1998 <- 0 ]
    [ 1999 <- 0 ]
    [ 2000 <- 0 ]
    [ 2001 <- 0 ]
    [ 2002 <- 0 ]
    [ 2003 <- 0 ]
    [ 2004 <- 0 ]
    [ 2005 <- 0 ]
    [ 2006 <- 0 ]
    [ 2007 <- 0 ]
    [ 2008 <- 0 ]
    [ 2009 <- 0 ]
    [ 2010 <- 0 ]
    [ 2011 <- 0 ]
    [ 2012 <- 0 ]
    [ 2013 <- 0 ]
    [ 2014 <- 0 ]
    [ 2015 <- 0 ]
    [ 1568 := #buf(32, 384) ]
    [ 1728 := #buf(32, 384) ]                                       /* offset to signature */
    [ 2016 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /* signature */ /* memcpy(<- 544, 128) */
    [ 1536 := #buf(32, 96) ]                                        /* padding index */
    [ 1568 := #buf(32, 512) ]
    [ 1760 := #buf(32, 512) ]                                       /* offset to deposit_count */
    [ 2144 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]         /* deposit_count */ /* memcpy(<- 1440, 40) */
    [ 1536 := #buf(32, 32) ]                                        /* padding index */
    [ 2184 <- 0 ]
    [ 2185 <- 0 ]
    [ 2186 <- 0 ]
    [ 2187 <- 0 ]
    [ 2188 <- 0 ]
    [ 2189 <- 0 ]
    [ 2190 <- 0 ]
    [ 2191 <- 0 ]
    [ 2192 <- 0 ]
    [ 2193 <- 0 ]
    [ 2194 <- 0 ]
    [ 2195 <- 0 ]
    [ 2196 <- 0 ]
    [ 2197 <- 0 ]
    [ 2198 <- 0 ]
    [ 2199 <- 0 ]
    [ 2200 <- 0 ]
    [ 2201 <- 0 ]
    [ 2202 <- 0 ]
    [ 2203 <- 0 ]
    [ 2204 <- 0 ]
    [ 2205 <- 0 ]
    [ 2206 <- 0 ]
    [ 2207 <- 0 ]
    [ 1568 := #buf(32, 576) ]                                       /* offset pointer = size of log data */
LOCAL_MEM_LOG_ABSTRACT: MEM
    {LOCAL_MEM_DEPOSIT_FUNCTION_HASH}
    {VYPER_GENERATED_BOUNDS}
    ; function arguments and locals
    [  416 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* def deposit(pubkey: bytes[PUBKEY_LENGTH],                                    */
    [  496 := #buf(16, 0) ]
    [  512 := #buf(32, 0) ]
    [  544 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /*             withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],    */
    [  608 := #buf(32, 0) ]
    [  640 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /*             signature: bytes[SIGNATURE_LENGTH]):                             */
    [  768 := #buf(32, 0) ]
    [  800 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /*     deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei")            */
    [  832 := #buf(32, {GWEI_IN_WEI}) ]
    [  864 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]        /*     amount: bytes[8] = self.to_little_endian_64(deposit_amount)              */
    [  904 := #buf(24, 0) ]
LOCAL_MEM_DATA: {LOCAL_MEM_LOG}
    [ 1792 := #buf(32, 0) ]                             /* zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000 */
    ; compute pubkey_root
    [ 2016 := #buf(48, PUBKEY) ]                        /* memcpy(<- 352, 48) */
    [ 1888 := #buf(32, 0) ]                             /* memcpy(<- 1792, 32) */
    [ 1856 := #buf(32, 16) ]                            /* len=64 - PUBKEY_LENGTH */
    [ 2064 := #buf(16, 0) ]                             /* memcpy(<- 1888, 16) */
    [ 1984 := #buf(32, 64) ]
    [  192 := #buf(32, {PUBKEY_ROOT}) ]                 /* sha256(2016, 64) */
    [ 1824 := #buf(32, {PUBKEY_ROOT}) ]                 /* pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH))) */
    ; compute tmp1
    [ 2176 := #buf(96, SIGNATURE) ]                     /* memcpy(<- 576, 96) */
    [ 2144 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP1}) ]                        /* sha256(2176, 64) */
    [ 2688 := #buf(32, {TMP1}) ]                        /* sha256(slice(signature, start=0, len=64)), */
    ; compute tmp2
    [ 2368 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ++ #buf(32, 0) ++ #buf(32, {DEPOSIT_AMOUNT}) ]   /* memcpy(<- 640, 96) */   /* TODO: ??? */
    [ 2336 := #buf(32, 32) ]                            /* len=SIGNATURE_LENGTH - 64 */
    [ 2560 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]    /* memcpy(<- 2368, 32) */
    [ 2592 := #buf(32, 0) ]
    [ 2528 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP2}) ]                        /* sha256(2560, 64) */
    [ 2720 := #buf(32, {TMP2}) ]                        /* sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)), */
    ; compute signature_root
    [ 2656 := #buf(32, 64) ]
    [  192 := #buf(32, {SIGNATURE_ROOT}) ]              /* sha256(2688, 64) */
    [ 2112 := #buf(32, {SIGNATURE_ROOT}) ]              /* signature_root: bytes32 = sha256(concat(...)) */
    ; compute tmp3
    [ 2848 := #buf(32, {PUBKEY_ROOT}) ]
    [ 2880 := #buf(32, WITHDRAWAL_CREDENTIALS) ]        /* memcpy(<- 480, 32) */
    [ 2816 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP3}) ]                        /* sha256(2848, 64) */
    [ 3232 := #buf(32, {TMP3}) ]                        /* sha256(concat(pubkey_root, withdrawal_credentials)), */
    ; compute tmp4
    [ 3104 := #bufSeg(#buf(32, YY8), 24, 8) ]           /* memcpy(<- 800, 8) */
    [ 2976 := #buf(32, 0) ]                             /* memcpy(<- 1792, 32) */
    [ 2944 := #buf(32, 24) ]                            /* len=32 - AMOUNT_LENGTH */
    [ 3112 := #buf(24, 0) ]                             /* memcpy(<- 2976, 24) */
    [ 3136 := #buf(32, {SIGNATURE_ROOT}) ]
    [ 3072 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP4}) ]                        /* sha256(3104, 64) */
    [ 3264 := #buf(32, {TMP4}) ]                        /* sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)), */
    ; compute node
    [ 3200 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE}) ]                        /* sha256(3232, 64) */
    [ 2784 := #buf(32, {NODE}) ]                        /* node: bytes32 = sha256(concat(...)) */
PUBKEY_ROOT: #sha256(#buf(48, PUBKEY) ++ #buf(16, 0))
TMP1: #sha256(#bufSeg(#buf(96, SIGNATURE), 0, 64))
TMP2: #sha256(#bufSeg(#buf(96, SIGNATURE), 64, 32) ++ #buf(32, 0))
SIGNATURE_ROOT: #sha256(#buf(32, {TMP1}) ++ #buf(32, {TMP2}))
TMP3: #sha256(#buf(32, {PUBKEY_ROOT}) ++ #buf(32, WITHDRAWAL_CREDENTIALS))
TMP4: #sha256(#bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ++ #buf(32, {SIGNATURE_ROOT}))
NODE: #sha256(#buf(32, {TMP3}) ++ #buf(32, {TMP4}))
PC_SUBCALL_1:    1758
PC_SUBCALL_2:    1982
PC_LOG:          2204
PC_DATA:         3036
PC_ADD_BEGIN:    3923
PC_ADD_LOOPHEAD: 4163
PC_ADD_END:      4173

; @payable
; @public
; def deposit(pubkey: bytes[PUBKEY_LENGTH],
;             withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],
;             signature: bytes[SIGNATURE_LENGTH]):
;
;     # Avoid overflowing the Merkle tree (and prevent edge case in computing `self.branch`)
;     assert self.deposit_count < MAX_DEPOSIT_COUNT
;
;     # Validate deposit data
;     deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei")
;     assert deposit_amount >= MIN_DEPOSIT_AMOUNT
;     assert len(pubkey) == PUBKEY_LENGTH
;     assert len(withdrawal_credentials) == WITHDRAWAL_CREDENTIALS_LENGTH
;     assert len(signature) == SIGNATURE_LENGTH

[deposit-init]
pc: 0 => {PC_SUBCALL_1}
word_stack: .WordStack
local_mem: .Map => {LOCAL_MEM_INIT}
; gas usage = 765 + ( 82 = 3*n + n^2 / 512 where n = 27 = 864 / 32 )
gas:         #symGas(G, 0 => 744, 0 => 744, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 768, .Set)

;    # Emit `DepositEvent` log
;    amount: bytes[8] = self.to_little_endian_64(deposit_amount)
;    log.DepositEvent(pubkey, withdrawal_credentials, amount, signature, self.to_little_endian_64(self.deposit_count))

[deposit-subcall_1]
pc: {PC_SUBCALL_1} => {PC_SUBCALL_2}
word_stack: .WordStack
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_SUBCALL_1}
gas:         #symGas(G, 0 => 10914, 0 => 10914, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(864 => 1152, .Set)

[deposit-subcall_2]
pc: {PC_SUBCALL_2} => {PC_LOG}
word_stack: .WordStack
local_mem: {LOCAL_MEM_SUBCALL_1} => {LOCAL_MEM_SUBCALL_2}
gas:         #symGas(G, 0 => 12343, 0 => 12343, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(1216 => 1480, .Set)

[deposit-log]
pc: {PC_LOG} => {PC_DATA}
word_stack: .WordStack
local_mem: {LOCAL_MEM_SUBCALL_2} => {LOCAL_MEM_LOG}
gas:         #symGas(G, 0 => 16849, 0 => 16849, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(1472 => 2208, .Set)
log: _ => _
; TODO: fix log
; log: _:List ( .List => ListItem(#abiEventLog(THIS, "DepositEvent",
;             #bytes(#buf({PUBKEY_LENGTH}, PUBKEY)),
;             #bytes(#buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)),
;             #bytes(#bufSeg(#buf(32, YY8), 24, 8)),
;             #bytes(#buf({SIGNATURE_LENGTH}, SIGNATURE)),
;             #bytes(#bufSeg(#buf(32, Y8), 24, 8)) )))

;    # Compute `DepositData` hash tree root
;    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000
;    pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH)))
;    signature_root: bytes32 = sha256(concat(
;        sha256(slice(signature, start=0, len=64)),                                                             <-- tmp1
;        sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)),                   <-- tmp2
;    ))
;    node: bytes32 = sha256(concat(
;        sha256(concat(pubkey_root, withdrawal_credentials)),                                                   <-- tmp3
;        sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)),          <-- tmp4
;    ))

; #### `DepositData`
;
; ```python
; class DepositData(Container):
;     pubkey: BLSPubkey
;     withdrawal_credentials: Hash
;     amount: Gwei
;     signature: BLSSignature
; ```

;                                    ___________________________ node _________________________
;                                   /                                                          \
;                    __________ tmp3 ___________________                        ______________ tmp4 _______________
;                   /                                   \                      /                                   \
;           pubkey_root                       withdrawal_credentials       amount                        _____ signature_root __________
;           /       \                                                                                   /                               \
;   pubkey[0:32]  pubkey[32:48]++zero[0:16]                                                           tmp1                             tmp2
;                                                                                                  /       \                        /        \
;                                                                                       signature[0:32]  signature[32:64]  signature[64:96]  zero[0:32]

[deposit-data]
pc: {PC_DATA} => {PC_ADD_BEGIN}
word_stack: .WordStack
local_mem: {LOCAL_MEM_LOG} => {LOCAL_MEM_DATA}
+requires:
    // conditions
    andBool {NODE} ==Int DEPOSIT_DATA_ROOT
gas:         #symGas(G, 0 => 14376, 0 => 14376, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(2240 => 3296, .Set)

;    # Add `DepositData` hash tree root to Merkle tree (update a single `branch` node)
;    self.deposit_count += 1
;    size: uint256 = self.deposit_count
;    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):
;        if bitwise_and(size, 1) == 1:  # More gas efficient than `size % 2 == 1`
;            self.branch[height] = node
;            break
;        node = sha256(concat(self.branch[height], node))
;        size /= 2

[deposit-add]
WORD_STACK_INIT: 32 : 3360 : .WordStack

[deposit-add-init]
;

[deposit-add-init-then]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_ADD_BEGIN} => {PC_ADD_END}
word_stack: .WordStack
local_mem: {LOCAL_MEM_DATA} => {LOCAL_MEM_DATA}
    [ 3328 := #buf(32, DEPOSIT_COUNT +Int 1) ]          /* size: uint256 = self.deposit_count */
    [ 3360 := #buf(32, 0) ]                             /* height */
    [  192 := #buf(32, 0) ]
storage: M => M
    [ #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList) <- DEPOSIT_COUNT +Int 1 ]
    [ #hashedLocation({COMPILER}, {BRANCH}, 0)               <- {NODE} ]
refund: _ => _
+requires:
    // conditions
    andBool (DEPOSIT_COUNT +Int 1) &Int 1 ==Int 1
gas:         #symGas(G, 0 => 11019, 0 => 41019, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(3296 => 3392, .Set)

[deposit-add-init-else]
pc: {PC_ADD_BEGIN} => {PC_ADD_LOOPHEAD}
word_stack: .WordStack => 1 : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_DATA} => {LOCAL_MEM_DATA}
    [ 3328 := #buf(32, DEPOSIT_COUNT +Int 1) ]          /* size: uint256 = self.deposit_count */
    [ 3360 := #buf(32, 0) ]                             /* height */
    [  192 := #buf(32, 0) ]
    [ 3424 := #buf(32, {BRANCH_0}) ]
    [ 3456 := #buf(32, {NODE}) ]
    [ 3392 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE_1}) ]                      /* sha256(3424, 64) */
    [ 2784 := #buf(32, {NODE_1}) ]                      /* node = sha256(concat(self.branch[height], node)) */
    [ 3328 := #buf(32, (DEPOSIT_COUNT +Int 1) /Int 2) ] /* update size */
    [ 3360 := #buf(32, 1) ]                             /* update height */
BRANCH_0: select(M, #hashedLocation({COMPILER}, {BRANCH}, 0))
NODE_1: #sha256(#buf(32, {BRANCH_0}) ++ #buf(32, {NODE}))
storage: M => M
    [ #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList) <- DEPOSIT_COUNT +Int 1 ]
refund: _ => _
+requires:
    // conditions
    andBool (DEPOSIT_COUNT +Int 1) &Int 1 =/=Int 1
gas:         #symGas(G, 0 => 7196, 0 => 22196, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(3296 => 3488, .Set)

[deposit-add-loop]
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_DATA}
    [ 3328 := #buf(32, SIZE) ]                      /* size */
    [ 3360 := #buf(32, HEIGHT) ]                    /* height */
    [  192 := #buf(32, 0) ]
    [ 3424 := #buf(32, ANON_1) ]
    [ 3456 := #buf(32, ANON_2) ]
    [ 3392 := #buf(32, 64) ]
    [  192 := #buf(32, NODE) ]                      /* sha256(3456, 64) */
    [ 2784 := #buf(32, NODE) ]                      /* node = sha256(concat(self.branch[height], node)) */
+requires:
    // conditions
    andBool #range(0 <= HEIGHT <= 32)
    // types
    andBool #rangeUInt(256, NODE)
    andBool #rangeUInt(256, SIZE)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)

[deposit-add-loop-enter]
+requires:
    // conditions
    andBool HEIGHT <Int 32

[deposit-add-loop-enter-then]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_ADD_LOOPHEAD} => {PC_ADD_END}
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [  192 := #buf(32, 0) ]
storage: M => M
    [ #hashedLocation({COMPILER}, {BRANCH}, HEIGHT) <- NODE ]
refund: _ => _
+requires:
    // conditions
    andBool SIZE &Int 1 ==Int 1
gas:         #symGas(G, 0 => 5162, 0 => 20162, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(3488, .Set)

[deposit-add-loop-enter-else]
pc: {PC_ADD_LOOPHEAD}
word_stack: (HEIGHT => HEIGHT +Int 1) : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [  192 := #buf(32, 0) ]
    [ 3424 := #buf(32, {BRANCH_HEIGHT}) ]
    [ 3456 := #buf(32, NODE) ]
    [ 3392 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE_NEW}) ]                    /* sha256(3456, 64) */
    [ 2784 := #buf(32, {NODE_NEW}) ]                    /* node = sha256(concat(self.branch[height], node)) */
    [ 3328 := #buf(32, SIZE /Int 2) ]                   /* update size */
    [ 3360 := #buf(32, HEIGHT +Int 1) ]                 /* update height */
BRANCH_HEIGHT: select(M, #hashedLocation({COMPILER}, {BRANCH}, HEIGHT))
NODE_NEW: #sha256(#buf(32, {BRANCH_HEIGHT}) ++ #buf(32, NODE))
+requires:
    // conditions
    andBool SIZE &Int 1 =/=Int 1
gas:         #symGas(G, 0 => 1339, 0 => 1339, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(3488, .Set)

[deposit-add-loop-exit]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_ADD_LOOPHEAD} => {PC_ADD_END}
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD}
+requires:
    // conditions
    andBool HEIGHT ==Int 32
gas:         #symGas(G, 0 => 27, 0 => 27, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(3488, .Set)

;
; revert cases
;

[revert]
k: #execute => #halt
status_code: _ => EVMC_REVERT

; Revert if the first four bytes are invalid (or not fully provided).
[revert-invalid_function_identifier]
call_data: #buf(CALL_DATA_SIZE, CALL_DATA)
pc: 0 => 4179
gas:         #symGas(G, 0 => 170, 0 => 170, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)

[revert-invalid_function_identifier-lt_4]
+requires:
    // conditions
    andBool #range(0 <= CALL_DATA_SIZE < 4)
    andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 3321006383 /* 0xc5f2892f get_deposit_root */
    andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 1646252336 /* 0x621fd130 get_deposit_count  */
    andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 579424536  /* 0x22895118 deposit            */

[revert-invalid_function_identifier-ge_4]
+requires:
    // conditions
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 3321006383 /* 0xc5f2892f get_deposit_root */
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 1646252336 /* 0x621fd130 get_deposit_count  */
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 579424536  /* 0x22895118 deposit            */

[revert-invalid_function_identifier-ge_4-lt_32]
+requires:
    // conditions
    andBool #range(4 <= CALL_DATA_SIZE < 32)

[revert-invalid_function_identifier-ge_4-ge_32]
+requires:
    // conditions
    andBool CALL_DATA_SIZE >=Int 32

[revert-init]
code: {INIT_CODE}
pc: 0 => 151
+requires:
    // conditions
    andBool CALL_VALUE =/=Int 0
gas:         #symGas(G, 0 => 69, 0 => 69, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)

[revert-get_deposit_root]
call_data: #abiCallData("get_deposit_root", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
pc: 0 => 638
+requires:
    // conditions
    andBool CALL_VALUE =/=Int 0
gas:         #symGas(G, 0 => 129, 0 => 129, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)

[revert-get_deposit_count]
call_data: #abiCallData("get_deposit_count", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
pc: 0 => 1296
+requires:
    // conditions
    andBool CALL_VALUE =/=Int 0
gas:         #symGas(G, 0 => 158, 0 => 158, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)


; TODO:

[deposit-revert-1]
k: #execute => #halt
status_code: _ => EVMC_REVERT
pc: 0 => 1697
+requires:
    // conditions
    andBool DEPOSIT_COUNT >=Int {MAX_DEPOSIT_COUNT}
gas:         #symGas(G, 0 => _, 0 => _, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)

[deposit-revert-2]
k: #execute => #halt
status_code: _ => EVMC_REVERT
pc: 0 => 1749
+requires:
    // conditions
    andBool DEPOSIT_COUNT <Int {MAX_DEPOSIT_COUNT}
    andBool CALL_VALUE /Int {GWEI_IN_WEI} <Int {MIN_DEPOSIT_AMOUNT}
gas:         #symGas(G, 0 => _, 0 => _, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)



;
; globals
;

[pgm]
COMPILER: "Vyper"
; Storage variables:
; branch: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]
; deposit_count: uint256
; zero_hashes: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]
BRANCH: 0
DEPOSIT_COUNT: 1
ZERO_HASHES: 2
; Constants:
; MIN_DEPOSIT_AMOUNT: constant(uint256) = 1000000000  # Gwei
; DEPOSIT_CONTRACT_TREE_DEPTH: constant(uint256) = 32
; MAX_DEPOSIT_COUNT: constant(uint256) = 4294967295 # 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1
; PUBKEY_LENGTH: constant(uint256) = 48  # bytes
; WITHDRAWAL_CREDENTIALS_LENGTH: constant(uint256) = 32  # bytes
; AMOUNT_LENGTH: constant(uint256) = 8  # bytes
; SIGNATURE_LENGTH: constant(uint256) = 96  # bytes
DEPOSIT_CONTRACT_TREE_DEPTH: 32
; bytecode
RUNTIME_CODE: "0x600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052600015610265575b6101605261014052600061018052610140516101a0526101c060006008818352015b61018051600860008112156100da578060000360020a82046100e1565b8060020a82025b905090506101805260ff6101a051166101e052610180516101e0516101805101101561010c57600080fd5b6101e0516101805101610180526101a0517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86000811215610155578060000360020a820461015c565b8060020a82025b905090506101a0525b81516001018083528114156100bd575b50506018600860208206610200016020828401111561019357600080fd5b60208061022082610180600060046015f15050818152809050905090508051602001806102c0828460006004600a8704601201f16101d057600080fd5b50506103206102c0516020818352015b60206103205111156101f15761020d565b6000610320516102e001535b81516001018083528114156101e0575b505060206102a05260406102c0510160206001820306601f8201039050610280525b6000610280511115156102415761025d565b602061028051036102a00151602061028051036102805261022f565b610160515650005b63c5f2892f60005114156104f757341561027e57600080fd5b6000610140526101405161016052600154610180526101a060006020818352015b60016001610180511614156103205760006101a051602081106102c157600080fd5b600060c052602060c02001546020826102400101526020810190506101605160208261024001015260208101905080610240526102409050602060c0825160208401600060025af161031257600080fd5b60c05190506101605261038e565b6000610160516020826101c00101526020810190506101a0516020811061034657600080fd5b600260c052602060c02001546020826101c0010152602081019050806101c0526101c09050602060c0825160208401600060025af161038457600080fd5b60c0519050610160525b610180600261039c57600080fd5b60028151048152505b815160010180835281141561029f575b505060006101605160208261046001015260208101905061014051610160516101805163806732896102e05260015461030052610300516006580161009b565b506103605260006103c0525b6103605160206001820306601f82010390506103c0511015156104235761043c565b6103c05161038001526103c0516020016103c052610401565b61018052610160526101405261036060088060208461046001018260208501600060046012f150508051820191505060006018602082066103e0016020828401111561048757600080fd5b60208061040082610140600060046015f150508181528090509050905060188060208461046001018260208501600060046014f150508051820191505080610460526104609050602060c0825160208401600060025af16104e757600080fd5b60c051905060005260206000f350005b63621fd13060005114156105f857341561051057600080fd5b63806732896101405260015461016052610160516006580161009b565b506101c0526000610220525b6101c05160206001820306601f82010390506102205110151561055b57610574565b610220516101e001526102205160200161022052610539565b6101c0805160200180610280828460006004600a8704601201f161059757600080fd5b50506102e0610280516020818352015b60206102e05111156105b8576105d4565b60006102e0516102a001535b81516001018083528114156105a7575b50506020610260526040610280510160206001820306601f8201039050610260f350005b6322895118600051141561105157605060043560040161014037603060043560040135111561062657600080fd5b60406024356004016101c037602060243560040135111561064657600080fd5b608060443560040161022037606060443560040135111561066657600080fd5b63ffffffff6001541061067857600080fd5b633b9aca006102e0526102e05161068e57600080fd5b6102e05134046102c052633b9aca006102c05110156106ac57600080fd5b603061014051146106bc57600080fd5b60206101c051146106cc57600080fd5b606061022051146106dc57600080fd5b610140610360525b61036051516020610360510161036052610360610360511015610706576106e4565b6380673289610380526102c0516103a0526103a0516006580161009b565b50610400526000610460525b6104005160206001820306601f8201039050610460511015156107525761076b565b6104605161042001526104605160200161046052610730565b610340610360525b610360515260206103605103610360526101406103605110151561079657610773565b610400805160200180610300828460006004600a8704601201f16107b957600080fd5b5050610140610480525b610480515160206104805101610480526104806104805110156107e5576107c3565b63806732896104a0526001546104c0526104c0516006580161009b565b50610520526000610580525b6105205160206001820306601f82010390506105805110151561083057610849565b610580516105400152610580516020016105805261080e565b610460610480525b610480515260206104805103610480526101406104805110151561087457610851565b6105208051602001806105a0828460006004600a8704601201f161089757600080fd5b505060a06106205261062051610660526101408051602001806106205161066001828460006004600a8704601201f16108cf57600080fd5b5050610600610620516106600151610240818352015b6102406106005111156108f757610918565b600061060051610620516106800101535b81516001018083528114156108e5575b5050602061062051610660015160206001820306601f82010390506106205101016106205261062051610680526101c08051602001806106205161066001828460006004600a8704601201f161096d57600080fd5b5050610600610620516106600151610240818352015b610240610600511115610995576109b6565b600061060051610620516106800101535b8151600101808352811415610983575b5050602061062051610660015160206001820306601f820103905061062051010161062052610620516106a0526103008051602001806106205161066001828460006004600a8704601201f1610a0b57600080fd5b5050610600610620516106600151610240818352015b610240610600511115610a3357610a54565b600061060051610620516106800101535b8151600101808352811415610a21575b5050602061062051610660015160206001820306601f820103905061062051010161062052610620516106c0526102208051602001806106205161066001828460006004600a8704601201f1610aa957600080fd5b5050610600610620516106600151610240818352015b610240610600511115610ad157610af2565b600061060051610620516106800101535b8151600101808352811415610abf575b5050602061062051610660015160206001820306601f820103905061062051010161062052610620516106e0526105a08051602001806106205161066001828460006004600a8704601201f1610b4757600080fd5b5050610600610620516106600151610240818352015b610240610600511115610b6f57610b90565b600061060051610620516106800101535b8151600101808352811415610b5d575b5050602061062051610660015160206001820306601f8201039050610620510101610620527f649bbc62d0e31342afea4e5cd82d4049e7e1ee912fc0889aa790803be39038c561062051610660a160006107005260006101406030806020846107c001018260208501600060046016f150508051820191505060006010602082066107400160208284011115610c2557600080fd5b60208061076082610700600060046015f15050818152809050905090506010806020846107c001018260208501600060046013f1505080518201915050806107c0526107c09050602060c0825160208401600060025af1610c8557600080fd5b60c0519050610720526000600060406020820661086001610220518284011115610cae57600080fd5b606080610880826020602088068803016102200160006004601bf1505081815280905090509050602060c0825160208401600060025af1610cee57600080fd5b60c0519050602082610a600101526020810190506000604060206020820661092001610220518284011115610d2257600080fd5b606080610940826020602088068803016102200160006004601bf15050818152809050905090506020806020846109e001018260208501600060046015f1505080518201915050610700516020826109e0010152602081019050806109e0526109e09050602060c0825160208401600060025af1610d9f57600080fd5b60c0519050602082610a6001015260208101905080610a6052610a609050602060c0825160208401600060025af1610dd657600080fd5b60c0519050610840526000600061072051602082610b000101526020810190506101c0602080602084610b0001018260208501600060046015f150508051820191505080610b0052610b009050602060c0825160208401600060025af1610e3c57600080fd5b60c0519050602082610c800101526020810190506000610300600880602084610c0001018260208501600060046012f15050805182019150506000601860208206610b800160208284011115610e9157600080fd5b602080610ba082610700600060046015f1505081815280905090509050601880602084610c0001018260208501600060046014f150508051820191505061084051602082610c0001015260208101905080610c0052610c009050602060c0825160208401600060025af1610f0457600080fd5b60c0519050602082610c8001015260208101905080610c8052610c809050602060c0825160208401600060025af1610f3b57600080fd5b60c0519050610ae052606435610ae05114610f5557600080fd5b6001805460018254011015610f6957600080fd5b6001815401815550600154610d0052610d2060006020818352015b60016001610d0051161415610fb957610ae051610d205160208110610fa857600080fd5b600060c052602060c020015561104d565b6000610d205160208110610fcc57600080fd5b600060c052602060c0200154602082610d40010152602081019050610ae051602082610d4001015260208101905080610d4052610d409050602060c0825160208401600060025af161101d57600080fd5b60c0519050610ae052610d00600261103457600080fd5b60028151048152505b8151600101808352811415610f84575b5050005b60006000fd"
INIT_CODE: "0x740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052341561009857600080fd5b6101406000601f818352015b600061014051602081106100b757600080fd5b600260c052602060c020015460208261016001015260208101905061014051602081106100e357600080fd5b600260c052602060c020015460208261016001015260208101905080610160526101609050602060c0825160208401600060025af161012157600080fd5b60c0519050606051600161014051018060405190131561014057600080fd5b809190121561014e57600080fd5b6020811061015b57600080fd5b600260c052602060c02001555b81516001018083528114156100a4575b50506111d656600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052600015610265575b6101605261014052600061018052610140516101a0526101c060006008818352015b61018051600860008112156100da578060000360020a82046100e1565b8060020a82025b905090506101805260ff6101a051166101e052610180516101e0516101805101101561010c57600080fd5b6101e0516101805101610180526101a0517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86000811215610155578060000360020a820461015c565b8060020a82025b905090506101a0525b81516001018083528114156100bd575b50506018600860208206610200016020828401111561019357600080fd5b60208061022082610180600060046015f15050818152809050905090508051602001806102c0828460006004600a8704601201f16101d057600080fd5b50506103206102c0516020818352015b60206103205111156101f15761020d565b6000610320516102e001535b81516001018083528114156101e0575b505060206102a05260406102c0510160206001820306601f8201039050610280525b6000610280511115156102415761025d565b602061028051036102a00151602061028051036102805261022f565b610160515650005b63c5f2892f60005114156104f757341561027e57600080fd5b6000610140526101405161016052600154610180526101a060006020818352015b60016001610180511614156103205760006101a051602081106102c157600080fd5b600060c052602060c02001546020826102400101526020810190506101605160208261024001015260208101905080610240526102409050602060c0825160208401600060025af161031257600080fd5b60c05190506101605261038e565b6000610160516020826101c00101526020810190506101a0516020811061034657600080fd5b600260c052602060c02001546020826101c0010152602081019050806101c0526101c09050602060c0825160208401600060025af161038457600080fd5b60c0519050610160525b610180600261039c57600080fd5b60028151048152505b815160010180835281141561029f575b505060006101605160208261046001015260208101905061014051610160516101805163806732896102e05260015461030052610300516006580161009b565b506103605260006103c0525b6103605160206001820306601f82010390506103c0511015156104235761043c565b6103c05161038001526103c0516020016103c052610401565b61018052610160526101405261036060088060208461046001018260208501600060046012f150508051820191505060006018602082066103e0016020828401111561048757600080fd5b60208061040082610140600060046015f150508181528090509050905060188060208461046001018260208501600060046014f150508051820191505080610460526104609050602060c0825160208401600060025af16104e757600080fd5b60c051905060005260206000f350005b63621fd13060005114156105f857341561051057600080fd5b63806732896101405260015461016052610160516006580161009b565b506101c0526000610220525b6101c05160206001820306601f82010390506102205110151561055b57610574565b610220516101e001526102205160200161022052610539565b6101c0805160200180610280828460006004600a8704601201f161059757600080fd5b50506102e0610280516020818352015b60206102e05111156105b8576105d4565b60006102e0516102a001535b81516001018083528114156105a7575b50506020610260526040610280510160206001820306601f8201039050610260f350005b6322895118600051141561105157605060043560040161014037603060043560040135111561062657600080fd5b60406024356004016101c037602060243560040135111561064657600080fd5b608060443560040161022037606060443560040135111561066657600080fd5b63ffffffff6001541061067857600080fd5b633b9aca006102e0526102e05161068e57600080fd5b6102e05134046102c052633b9aca006102c05110156106ac57600080fd5b603061014051146106bc57600080fd5b60206101c051146106cc57600080fd5b606061022051146106dc57600080fd5b610140610360525b61036051516020610360510161036052610360610360511015610706576106e4565b6380673289610380526102c0516103a0526103a0516006580161009b565b50610400526000610460525b6104005160206001820306601f8201039050610460511015156107525761076b565b6104605161042001526104605160200161046052610730565b610340610360525b610360515260206103605103610360526101406103605110151561079657610773565b610400805160200180610300828460006004600a8704601201f16107b957600080fd5b5050610140610480525b610480515160206104805101610480526104806104805110156107e5576107c3565b63806732896104a0526001546104c0526104c0516006580161009b565b50610520526000610580525b6105205160206001820306601f82010390506105805110151561083057610849565b610580516105400152610580516020016105805261080e565b610460610480525b610480515260206104805103610480526101406104805110151561087457610851565b6105208051602001806105a0828460006004600a8704601201f161089757600080fd5b505060a06106205261062051610660526101408051602001806106205161066001828460006004600a8704601201f16108cf57600080fd5b5050610600610620516106600151610240818352015b6102406106005111156108f757610918565b600061060051610620516106800101535b81516001018083528114156108e5575b5050602061062051610660015160206001820306601f82010390506106205101016106205261062051610680526101c08051602001806106205161066001828460006004600a8704601201f161096d57600080fd5b5050610600610620516106600151610240818352015b610240610600511115610995576109b6565b600061060051610620516106800101535b8151600101808352811415610983575b5050602061062051610660015160206001820306601f820103905061062051010161062052610620516106a0526103008051602001806106205161066001828460006004600a8704601201f1610a0b57600080fd5b5050610600610620516106600151610240818352015b610240610600511115610a3357610a54565b600061060051610620516106800101535b8151600101808352811415610a21575b5050602061062051610660015160206001820306601f820103905061062051010161062052610620516106c0526102208051602001806106205161066001828460006004600a8704601201f1610aa957600080fd5b5050610600610620516106600151610240818352015b610240610600511115610ad157610af2565b600061060051610620516106800101535b8151600101808352811415610abf575b5050602061062051610660015160206001820306601f820103905061062051010161062052610620516106e0526105a08051602001806106205161066001828460006004600a8704601201f1610b4757600080fd5b5050610600610620516106600151610240818352015b610240610600511115610b6f57610b90565b600061060051610620516106800101535b8151600101808352811415610b5d575b5050602061062051610660015160206001820306601f8201039050610620510101610620527f649bbc62d0e31342afea4e5cd82d4049e7e1ee912fc0889aa790803be39038c561062051610660a160006107005260006101406030806020846107c001018260208501600060046016f150508051820191505060006010602082066107400160208284011115610c2557600080fd5b60208061076082610700600060046015f15050818152809050905090506010806020846107c001018260208501600060046013f1505080518201915050806107c0526107c09050602060c0825160208401600060025af1610c8557600080fd5b60c0519050610720526000600060406020820661086001610220518284011115610cae57600080fd5b606080610880826020602088068803016102200160006004601bf1505081815280905090509050602060c0825160208401600060025af1610cee57600080fd5b60c0519050602082610a600101526020810190506000604060206020820661092001610220518284011115610d2257600080fd5b606080610940826020602088068803016102200160006004601bf15050818152809050905090506020806020846109e001018260208501600060046015f1505080518201915050610700516020826109e0010152602081019050806109e0526109e09050602060c0825160208401600060025af1610d9f57600080fd5b60c0519050602082610a6001015260208101905080610a6052610a609050602060c0825160208401600060025af1610dd657600080fd5b60c0519050610840526000600061072051602082610b000101526020810190506101c0602080602084610b0001018260208501600060046015f150508051820191505080610b0052610b009050602060c0825160208401600060025af1610e3c57600080fd5b60c0519050602082610c800101526020810190506000610300600880602084610c0001018260208501600060046012f15050805182019150506000601860208206610b800160208284011115610e9157600080fd5b602080610ba082610700600060046015f1505081815280905090509050601880602084610c0001018260208501600060046014f150508051820191505061084051602082610c0001015260208101905080610c0052610c009050602060c0825160208401600060025af1610f0457600080fd5b60c0519050602082610c8001015260208101905080610c8052610c809050602060c0825160208401600060025af1610f3b57600080fd5b60c0519050610ae052606435610ae05114610f5557600080fd5b6001805460018254011015610f6957600080fd5b6001815401815550600154610d0052610d2060006020818352015b60016001610d0051161415610fb957610ae051610d205160208110610fa857600080fd5b600060c052602060c020015561104d565b6000610d205160208110610fcc57600080fd5b600060c052602060c0200154602082610d40010152602081019050610ae051602082610d4001015260208101905080610d4052610d409050602060c0825160208401600060025af161101d57600080fd5b60c0519050610ae052610d00600261103457600080fd5b60028151048152505b8151600101808352811415610f84575b5050005b60006000fd5b61017f6111d60361017f60003961017f6111d6036000f3"
