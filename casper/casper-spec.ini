; casper commit: master b2a1189
; vyper  commit: master 7b1e018
; k      commit: master aa5aa63
; kevm   commit: ABI    77ebe3d

[recommended_target_hash]
comment: 
k: (#execute => #halt) ~> _
output: _ => #asByteStackInWidth(#recommendedBlockHash(BLOCK_HASHES, BLOCK_NUM, CUR_EPOCH, EPOCH_LENGTH), 32)
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("recommended_target_hash", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: GCAP => GCAP -Int 893
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: SetItem(CASPER_ACCT_ID) _:Set
casperBalance: CASPER_BAL
storage:
    // self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CUR_EPOCH)
    // self.EPOCH_LENGTH
    (#hashedLocation({COMPILER}, {EPOCH_LENGTH}, .IntList) |-> EPOCH_LENGTH)
    _:Map
accounts: 
requires:
    andBool 0  <Int CUR_EPOCH    andBool CUR_EPOCH    <=Int maxSInt128
    andBool 0  <Int EPOCH_LENGTH andBool EPOCH_LENGTH <=Int maxSInt128
    andBool 0 <=Int CASPER_BAL   andBool CASPER_BAL   <=Int maxUInt256
    // Overflow check
    andBool (CUR_EPOCH *Int EPOCH_LENGTH) <=Int maxSInt128
    andBool BLOCK_NUM -Int 256 <=Int #expectedBlockNumber(CUR_EPOCH, EPOCH_LENGTH)
    andBool #expectedBlockNumber(CUR_EPOCH, EPOCH_LENGTH) <Int BLOCK_NUM
    // Call depth
    andBool 0 <=Int CD andBool CD <Int 1024
    // Gas
    andBool GCAP >=Int 893
ensures:
attribute: 

;  def main_hash_voted_frac() -> decimal:
;    return min(self.votes[self.current_epoch].cur_dyn_votes[self.expected_source_epoch] / self.total_curdyn_deposits,
;               self.votes[self.current_epoch].prev_dyn_votes[self.expected_source_epoch] / self.total_prevdyn_deposits)
;    Possible cases:
;        1. RESULT_1 <=Int RESULT_2,
;        2. RESULT_1 >Int RESULT_2,
;        3. one of {TOTAL_CURDYN_DEPOSITS_VAL, TOTAL_PREVDYN_DEPOSITS_VAL} is 0.
;
[main_hash_voted_frac]
output: _ => _
memoryUsed: 0 => _
callDepth: CD
callStack: _
callData: #abiCallData("main_hash_voted_frac", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _:Map
pc: 0 => _
gas: 100000 => _
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList)          |-> CURRENT_EPOCH_VAL)
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList)  |-> EXPECTED_SOURCE_EPOCH_VAL)
    (#hashedLocation({COMPILER}, {VOTES}, CURRENT_EPOCH_VAL {CUR_DYN_VOTES} EXPECTED_SOURCE_EPOCH_VAL) |-> CUR_DYN_VOTES_VAL)
    (#hashedLocation({COMPILER}, {VOTES}, CURRENT_EPOCH_VAL {PREV_DYN_VOTES} EXPECTED_SOURCE_EPOCH_VAL) |-> PREV_DYN_VOTES_VAL)
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)  |-> TOTAL_CURDYN_DEPOSITS_VAL)
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> TOTAL_PREVDYN_DEPOSITS_VAL)
    _:Map
accounts:
requires:
    andBool #rangeSInt(128, CURRENT_EPOCH_VAL)
    andBool #rangeSInt(128, EXPECTED_SOURCE_EPOCH_VAL)
    andBool #rangeSFixed(128, 10, CUR_DYN_VOTES_VAL)
    andBool #rangeSFixed(128, 10, PREV_DYN_VOTES_VAL)
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS_VAL)
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS_VAL)
    andBool #range(0 <= CD < 1024)

    andBool CURRENT_EPOCH_VAL >=Int 0
    andBool EXPECTED_SOURCE_EPOCH_VAL >=Int 0
    andBool CUR_DYN_VOTES_VAL >=Int 0
    andBool PREV_DYN_VOTES_VAL >=Int 0
    andBool TOTAL_CURDYN_DEPOSITS_VAL >=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS_VAL >=Int 0

    /*votes in a dinasty will always be just a fraction of total deposits*/
    andBool CUR_DYN_VOTES_VAL <=Int TOTAL_CURDYN_DEPOSITS_VAL
    andBool PREV_DYN_VOTES_VAL <=Int TOTAL_PREVDYN_DEPOSITS_VAL
ensures:
attribute:

[main_hash_voted_frac-success-1]
k: (#execute => #halt) ~> _
statusCode: _ => EVMC_SUCCESS
output: _ => #asByteStackInWidth(RESULT_1, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS_VAL =/=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS_VAL =/=Int 0
    andBool RESULT_1 ==Int (CUR_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_CURDYN_DEPOSITS_VAL)
    andBool RESULT_2 ==Int (PREV_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_PREVDYN_DEPOSITS_VAL)
    andBool RESULT_1 <=Int RESULT_2
ensures:
    ensures 0 <=Int RESULT_1 andBool RESULT_1 <=Int VYPER_DEC_MULTIPLIER

[main_hash_voted_frac-success-2]
k: (#execute => #halt) ~> _
statusCode: _ => EVMC_SUCCESS
output: _ => #asByteStackInWidth(RESULT_2, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS_VAL =/=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS_VAL =/=Int 0
    andBool RESULT_1 ==Int (CUR_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_CURDYN_DEPOSITS_VAL)
    andBool RESULT_2 ==Int (PREV_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_PREVDYN_DEPOSITS_VAL)
    andBool RESULT_1 >Int RESULT_2
ensures:
    ensures 0 <=Int RESULT_2 andBool RESULT_2 <=Int VYPER_DEC_MULTIPLIER

[main_hash_voted_frac-failure]
k: (#execute => #halt) ~> _
statusCode: _ => EVMC_REVERT
+requires:
    andBool (TOTAL_CURDYN_DEPOSITS_VAL ==Int 0 orBool TOTAL_PREVDYN_DEPOSITS_VAL ==Int 0)

;def total_curdyn_deposits_scaled() -> wei_value:
;    return floor(self.total_curdyn_deposits * self.deposit_scale_factor[self.current_epoch])
[total_curdyn_deposits_scaled]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("total_curdyn_deposits_scaled", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    // self.total_curdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)  |-> TOTAL_CURDYN_DEPOSITS)
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    //self.deposit_scale_factor[self.current_epoch] : decimal
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    _:Map
accounts:
requires:
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #range(0 <= CD < 1024)

    andBool TOTAL_CURDYN_DEPOSITS   >=Int 0
    andBool CURRENT_EPOCH           >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR   >Int 0
attribute:
ensures:

[total_curdyn_deposits_scaled-success]
output: _ => #asByteStackInWidth(RESULT, 32)
statusCode: _ => EVMC_SUCCESS
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT <=Int maxDecimal
    andBool RESULT ==Int DECIMAL_RESULT /Int VYPER_DEC_MULTIPLIER
ensures:
    ensures #range(0 <= RESULT <= maxSInt128)

[total_curdyn_deposits_scaled-failure-1]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT >Int maxDecimal

[total_curdyn_deposits_scaled-failure-21]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256

    //does not work because chop() is not evaluated further when it has symbolic arguments
    /*andBool #range(0 <= (TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR) modInt pow256   <= maxSInt256)*/

    andBool #range(0 <= chop(TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)             <= maxSInt256)

[total_curdyn_deposits_scaled-failure-22]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(maxSInt256 <  chop(TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)            <= maxUInt256)

;def total_prevdyn_deposits_scaled() -> wei_value:
;    return floor(self.total_prevdyn_deposits * self.deposit_scale_factor[self.current_epoch])
[total_prevdyn_deposits_scaled]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("total_prevdyn_deposits_scaled", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    // self.total_prevdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> TOTAL_PREVDYN_DEPOSITS)
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    //self.deposit_scale_factor[self.current_epoch] : decimal
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    _:Map
accounts:
requires:
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #range(0 <= CD < 1024)

    andBool TOTAL_PREVDYN_DEPOSITS   >=Int 0
    andBool CURRENT_EPOCH           >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR   >Int 0
attribute:
ensures:

[total_prevdyn_deposits_scaled-success]
output: _ => #asByteStackInWidth(RESULT, 32)
statusCode: _ => EVMC_SUCCESS
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT <=Int maxDecimal
    andBool RESULT ==Int DECIMAL_RESULT /Int VYPER_DEC_MULTIPLIER
ensures:
    ensures #range(0 <= RESULT <= maxSInt128)

[total_prevdyn_deposits_scaled-failure-1]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT >Int maxDecimal

[total_prevdyn_deposits_scaled-failure-21]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(0 <= chop(TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)             <= maxSInt256)

[total_prevdyn_deposits_scaled-failure-22]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(maxSInt256 <  chop(TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)            <= maxUInt256)

;def deposit_size(validator_index: int128) -> int128(wei):
;    return floor(self.validators[validator_index].deposit * self.deposit_scale_factor[self.current_epoch])
[deposit_size]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("deposit_size", #int128(VALIDATOR_INDEX))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    // self.validators[validator_index].deposit : decimal
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {DEPOSIT}) |-> VALIDATOR_DEPOSIT)
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    //self.deposit_scale_factor[self.current_epoch] : decimal
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    _:Map
accounts:
requires:
    andBool #rangeSInt(128, VALIDATOR_INDEX)
    andBool #rangeSFixed(128, 10, VALIDATOR_DEPOSIT)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #range(0 <= CD < 1024)

    andBool VALIDATOR_INDEX         >=Int 0
    andBool VALIDATOR_DEPOSIT       >=Int 0
    andBool CURRENT_EPOCH           >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR   >Int 0
attribute:
ensures:

[deposit_size-success]
output: _ => #asByteStackInWidth(RESULT, 32)
statusCode: _ => EVMC_SUCCESS
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT <=Int maxDecimal
    andBool RESULT ==Int DECIMAL_RESULT /Int VYPER_DEC_MULTIPLIER
ensures:
    ensures #range(0 <= RESULT <= maxSInt128)

[deposit_size-failure-1]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT >Int maxDecimal

[deposit_size-failure-21]
statusCode: _ => EVMC_REVERT
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(0 <= chop(VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR)             <= maxSInt256)

[deposit_size-failure-22]
statusCode: _ => EVMC_REVERT
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(maxSInt256 <  chop(VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR)            <= maxUInt256)

[proc_reward]
comment: 
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("proc_reward", #int128(VINDEX), #int128(REWARD))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _ => _
coinbase: COINBASE_ACCT_ID
activeAccounts: SetItem(CASPER_ACCT_ID) SetItem(COINBASE_ACCT_ID) _:Set
casperBalance: CASPER_BAL => CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
storage:
    // self.validators[validator_index].deposit
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {DEPOSIT}) |-> (VDEPOSIT => VDEPOSIT +Int REWARD *Int 10000000000))
    // self.validators[validator_index].end_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {END_DYNASTY}) |-> END_DYN)
    // self.validators[validator_index].start_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {START_DYNASTY}) |-> START_DYN)
    // self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> CUR_DYN)
    // self.dynasty_wei_delta[end_dynasty]
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYN) |-> (#signed(DYN_WEI_DELTA) => #signed(DYN_WEI_DELTA -Int REWARD *Int 10000000000)))
    // self.total_curdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList) |-> (TOTAL_CUR_DYN_DEPOSITS => TOTAL_CUR_DYN_DEPOSITS  +Int REWARD *Int 10000000000))
    // self.total_prevdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList) |-> (TOTAL_PREV_DYN_DEPOSITS => TOTAL_PREV_DYN_DEPOSITS +Int REWARD *Int 10000000000))
    // self.deposit_scale_factor[self.current_epoch]
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CUR_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    // self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CUR_EPOCH)
    // self.default_end_dynasty
    (#hashedLocation({COMPILER}, {DEFAULT_END_DYNASTY}, .IntList) |-> DEFAULT_END_DYN)
    _:Map
accounts:
    <account>
      <acctID> COINBASE_ACCT_ID </acctID>
      <balance> COINBASE_BAL => COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000) </balance>
      <code> .WordStack </code>
      <storage> _ </storage>
      <nonce> COINBASE_NOUNCE </nonce>
    </account>
requires:
    // Type constraint
    andBool 0  <Int VINDEX                  andBool VINDEX                  <=Int maxSInt128
    andBool 0 <=Int REWARD                  andBool REWARD                  <=Int maxSInt128
    andBool 0  <Int COINBASE_ACCT_ID        andBool COINBASE_ACCT_ID        <=Int maxUInt160
    andBool (notBool COINBASE_ACCT_ID in #precompiledAccounts(BYZANTIUM))
    andBool 0 <=Int CASPER_BAL              andBool CASPER_BAL              <=Int maxUInt256
    andBool 0 <=Int VDEPOSIT                andBool VDEPOSIT                <=Int maxDecimal
    andBool 0 <=Int END_DYN                 andBool END_DYN                 <=Int maxSInt128
    andBool 0 <=Int START_DYN               andBool START_DYN               <=Int maxSInt128
    andBool 0 <=Int CUR_DYN                 andBool CUR_DYN                 <=Int maxSInt128
    andBool minDecimal <=Int DYN_WEI_DELTA  andBool DYN_WEI_DELTA           <=Int maxDecimal
    andBool 0 <=Int TOTAL_CUR_DYN_DEPOSITS  andBool TOTAL_CUR_DYN_DEPOSITS  <=Int maxDecimal
    andBool 0 <=Int TOTAL_PREV_DYN_DEPOSITS andBool TOTAL_PREV_DYN_DEPOSITS <=Int maxDecimal
    andBool 0  <Int CUR_EPOCH_SCALE_FACTOR  andBool CUR_EPOCH_SCALE_FACTOR  <=Int maxDecimal
    andBool 0  <Int CUR_EPOCH               andBool CUR_EPOCH               <=Int maxSInt128
    andBool 0 <=Int DEFAULT_END_DYN         andBool DEFAULT_END_DYN         <=Int maxSInt128
    andBool COINBASE_NOUNCE ==Int 1
    // andBool 0  <Int COINBASE_NOUNCE
    andBool 0 <=Int COINBASE_BAL            andBool COINBASE_BAL            <=Int maxUInt256
    // Overflow check
    andBool (VDEPOSIT +Int REWARD *Int 10000000000) <=Int maxDecimal
    andBool minDecimal <=Int (DYN_WEI_DELTA -Int REWARD *Int 10000000000)
    andBool TOTAL_CUR_DYN_DEPOSITS  +Int REWARD *Int 10000000000 <=Int maxDecimal
    andBool TOTAL_PREV_DYN_DEPOSITS +Int REWARD *Int 10000000000 <=Int maxDecimal
    andBool REWARD *Int CUR_EPOCH_SCALE_FACTOR <=Int maxDecimal
    andBool 0 <=Int CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
    andBool COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000) <=Int maxUInt256
    // Path condition
    andBool CALLER_ID ==Int CASPER_ACCT_ID
    andBool #inCurDynasty(START_DYN, END_DYN, CUR_DYN)
    andBool #inPrevDynasty(START_DYN, END_DYN, CUR_DYN)
    andBool END_DYN <Int DEFAULT_END_DYN
    andBool 0  <Int (REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000
    andBool CASPER_ACCT_ID =/=Int COINBASE_ACCT_ID
    // Call Depth
    andBool 0 <=Int CD andBool CD <Int 1024
    // Gas
    // andBool GCAP >=Int (92207 +Int 2300) // Gcallstipend
ensures: 
attribute: 


[vote]
comment: 
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("vote", #int128(VINDEX), #bytes32(T_HASH), #int128(T_EPOCH), #int128(S_EPOCH))
;callData: #abiCallData("vote", #bytes(1024, RLP(#int128(VINDEX), #bytes32(T_HASH), #int128(T_EPOCH), #int128(S_EPOCH), #bytes(1024, SIG))))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 10000000 => _
memoryUsed: 0 => _
callDepth: 0
log: _:List ( .List
            => ListItem(#abiEventLog(CASPER_ACCT_ID, "Epoch", #indexed(#int128(T_EPOCH)), #indexed(#bytes32(T_EPOCH_HASH)), #bool(1), #bool(0)))
               ListItem(#abiEventLog(CASPER_ACCT_ID, "Epoch", #indexed(#int128(S_EPOCH)), #indexed(#bytes32(S_EPOCH_HASH)), #bool(1), #bool(1)))
               ListItem(#abiEventLog(CASPER_ACCT_ID, "Vote", #indexed(#address(VWITHDRAWALADDR)), #indexed(#int128(VINDEX)), #indexed(#bytes32(T_HASH)), #int128(T_EPOCH), #int128(S_EPOCH)))
            )
refund: _ => _
coinbase: COINBASE_ACCT_ID
activeAccounts: SetItem(CASPER_ACCT_ID) SetItem(COINBASE_ACCT_ID) _:Set
casperBalance: CASPER_BAL
storage:
    // self.validators[validator_index].deposit
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {DEPOSIT}) |-> VDEPOSIT)
    // (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {DEPOSIT}) |-> (VDEPOSIT => VDEPOSIT +Int REWARD *Int 10000000000))
    // self.validators[validator_index].end_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {END_DYNASTY}) |-> END_DYN)
    // self.validators[validator_index].start_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {START_DYNASTY}) |-> START_DYN)
    // self.validators[validator_index].withdrawal_addr
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {WITHDRAWAL_ADDR}) |-> VWITHDRAWALADDR)
    // self.checkpoint_hashes[source_epoch]
    (#hashedLocation({COMPILER}, {CHECKPOINT_HASHES}, S_EPOCH) |-> S_EPOCH_HASH)
    // self.checkpoint_hashes[target_epoch]
    (#hashedLocation({COMPILER}, {CHECKPOINT_HASHES}, T_EPOCH) |-> T_EPOCH_HASH)
    // self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> CUR_DYN)
    // self.dynasty_wei_delta[end_dynasty]
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYN) |-> DYN_WEI_DELTA)
    // (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYN) |-> (#signed(DYN_WEI_DELTA) => #signed(DYN_WEI_DELTA -Int REWARD *Int 10000000000)))
    // self.total_curdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList) |-> TOTAL_CUR_DYN_DEPOSITS)
    // (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList) |-> (TOTAL_CUR_DYN_DEPOSITS => TOTAL_CUR_DYN_DEPOSITS  +Int REWARD *Int 10000000000))
    // self.total_prevdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList) |-> TOTAL_PREV_DYN_DEPOSITS)
    // (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList) |-> (TOTAL_PREV_DYN_DEPOSITS => TOTAL_PREV_DYN_DEPOSITS +Int REWARD *Int 10000000000))
    // assert self.votes[source_epoch].is_justified
    (#hashedLocation({COMPILER}, {VOTES}, S_EPOCH {IS_JUSTIFIED}) |-> 1)
    // self.votes[source_epoch].is_finalized
    (#hashedLocation({COMPILER}, {VOTES}, S_EPOCH {IS_FINALIZED}) |-> (_ => 1))
    // self.votes[target_epoch].cur_dyn_votes[source_epoch]
    (#hashedLocation({COMPILER}, {VOTES}, T_EPOCH {CUR_DYN_VOTES} S_EPOCH) |-> (CUR_DYN_VOTES => CUR_DYN_VOTES +Int VDEPOSIT))
    // self.votes[target_epoch].is_justified
    (#hashedLocation({COMPILER}, {VOTES}, T_EPOCH {IS_JUSTIFIED}) |-> (0 => 1))
    // self.votes[target_epoch].prev_dyn_votes[source_epoch]
    (#hashedLocation({COMPILER}, {VOTES}, T_EPOCH {PREV_DYN_VOTES} S_EPOCH) |-> (PREV_DYN_VOTES => PREV_DYN_VOTES +Int VDEPOSIT))
    // self.votes[target_epoch].vote_bitmap[floor(validator_index / 256)]
    (#hashedLocation({COMPILER}, {VOTES}, T_EPOCH {VOTE_BITMAP} VIDKEY) |-> (VOTE_VECTOR => #setVoteBit(VOTE_VECTOR, VINDEX)))
    // self.main_hash_justified
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (_ => 1))
    // self.deposit_scale_factor[self.current_epoch]
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CUR_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    // self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CUR_EPOCH)
    // self.last_finalized_epoch
    (#hashedLocation({COMPILER}, {LAST_FINALIZED_EPOCH}, .IntList) |-> (_ => S_EPOCH))
    // self.last_justified_epoch
    (#hashedLocation({COMPILER}, {LAST_JUSTIFIED_EPOCH}, .IntList) |-> (_ => T_EPOCH))
    // self.reward_factor
    (#hashedLocation({COMPILER}, {REWARD_FACTOR}, .IntList) |-> REWARD_FACTOR)
    // self.expected_source_epoch
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> EXPECTED_SOURCE_EPOCH)
    // self.EPOCH_LENGTH
    (#hashedLocation({COMPILER}, {EPOCH_LENGTH}, .IntList) |-> EPOCH_LENGTH)
    // self.DEFAULT_END_DYNASTY
    (#hashedLocation({COMPILER}, {DEFAULT_END_DYNASTY}, .IntList) |-> DEFAULT_END_DYN)
    _:Map
accounts:
    <account>
      <acctID> COINBASE_ACCT_ID </acctID>
      <balance> COINBASE_BAL </balance>
      <code> .WordStack </code>
      <storage> _ </storage>
      <nonce> COINBASE_NOUNCE </nonce>
    </account>
requires:
    // Type constraint
    andBool 0  <Int VINDEX                  andBool VINDEX                  <=Int maxSInt128  // start validator index counter at 1
    andBool 0 <=Int T_HASH                  andBool T_HASH                  <=Int maxUInt256
    andBool 0 <=Int T_EPOCH                 andBool T_EPOCH                 <=Int maxSInt128
    andBool 0 <=Int S_EPOCH                 andBool S_EPOCH                 <=Int maxSInt128
    andBool 0 <=Int CASPER_BAL              andBool CASPER_BAL              <=Int maxUInt256
    andBool 0  <Int COINBASE_ACCT_ID        andBool COINBASE_ACCT_ID        <=Int maxUInt160
    andBool (notBool COINBASE_ACCT_ID in #precompiledAccounts(BYZANTIUM))
    andBool 0 <=Int VDEPOSIT                andBool VDEPOSIT                <=Int maxDecimal
    andBool 0 <=Int END_DYN                 andBool END_DYN                 <=Int maxSInt128
    andBool 0 <=Int START_DYN               andBool START_DYN               <=Int maxSInt128
    andBool 0 <=Int VWITHDRAWALADDR         andBool VWITHDRAWALADDR         <=Int maxUInt160
    andBool 0 <=Int S_EPOCH_HASH            andBool S_EPOCH_HASH            <=Int maxUInt256
    andBool 0 <=Int T_EPOCH_HASH            andBool T_EPOCH_HASH            <=Int maxUInt256
    andBool 0 <=Int CUR_DYN                 andBool CUR_DYN                 <=Int maxSInt128
    andBool minDecimal <=Int DYN_WEI_DELTA  andBool DYN_WEI_DELTA           <=Int maxDecimal
    andBool 0 <=Int TOTAL_CUR_DYN_DEPOSITS  andBool TOTAL_CUR_DYN_DEPOSITS  <=Int maxDecimal
    andBool 0 <=Int TOTAL_PREV_DYN_DEPOSITS andBool TOTAL_PREV_DYN_DEPOSITS <=Int maxDecimal
    andBool 0 <=Int CUR_DYN_VOTES           andBool CUR_DYN_VOTES           <=Int maxDecimal
    andBool 0 <=Int PREV_DYN_VOTES          andBool PREV_DYN_VOTES          <=Int maxDecimal
    andBool 0 <=Int VOTE_VECTOR             andBool VOTE_VECTOR             <=Int maxUInt256
    andBool 0  <Int CUR_EPOCH_SCALE_FACTOR  andBool CUR_EPOCH_SCALE_FACTOR  <=Int maxDecimal
    andBool 0  <Int CUR_EPOCH               andBool CUR_EPOCH               <=Int maxSInt128
    andBool 0  <Int REWARD_FACTOR           andBool REWARD_FACTOR           <=Int maxDecimal  // assert self.reward_factor > 0 in `initialize_epoch()`
    andBool 0 <=Int EXPECTED_SOURCE_EPOCH   andBool EXPECTED_SOURCE_EPOCH   <=Int maxSInt128
    andBool 0  <Int EPOCH_LENGTH            andBool EPOCH_LENGTH            <=Int maxSInt128
    andBool VIDKEY ==Int VINDEX /Int 256
    andBool COINBASE_NOUNCE ==Int 1
    andBool 0 <=Int COINBASE_BAL            andBool COINBASE_BAL            <=Int maxUInt256
    // FIXME
    andBool 0 <Int VINDEX modInt 256
    // Overflow check
    andBool (CUR_EPOCH *Int EPOCH_LENGTH)    <=Int maxSInt128
    andBool (CUR_DYN_VOTES +Int VDEPOSIT)    <=Int maxDecimal
    andBool (PREV_DYN_VOTES +Int VDEPOSIT)   <=Int maxDecimal
    andBool (VDEPOSIT *Int REWARD_FACTOR)    <=Int maxDecimal
    andBool (TOTAL_CUR_DYN_DEPOSITS *Int 2)  <=Int maxDecimal
    andBool (TOTAL_PREV_DYN_DEPOSITS *Int 2) <=Int maxDecimal
    andBool (S_EPOCH +Int 1)                 <=Int maxSInt128
    andBool (VDEPOSIT +Int REWARD *Int 10000000000) <=Int maxDecimal
    andBool minDecimal <=Int (DYN_WEI_DELTA -Int REWARD *Int 10000000000)
    andBool TOTAL_CUR_DYN_DEPOSITS  +Int REWARD *Int 10000000000 <=Int maxDecimal
    andBool TOTAL_PREV_DYN_DEPOSITS +Int REWARD *Int 10000000000 <=Int maxDecimal
    andBool REWARD *Int CUR_EPOCH_SCALE_FACTOR <=Int maxDecimal
    andBool 0 <=Int CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
    andBool COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000) <=Int maxUInt256
    // Path constraint
    // recommended_target_hash
    andBool BLOCK_NUM -Int 256 <=Int #expectedBlockNumber(CUR_EPOCH, EPOCH_LENGTH)
    andBool #expectedBlockNumber(CUR_EPOCH, EPOCH_LENGTH) <Int BLOCK_NUM
    andBool #notVoteBefore(VOTE_VECTOR, VINDEX)
    // assert target_hash == self.recommended_target_hash()
    andBool T_HASH  ==Int #recommendedBlockHash(BLOCK_HASHES, BLOCK_NUM, CUR_EPOCH, EPOCH_LENGTH)
    // assert target_epoch == self.current_epoch
    andBool T_EPOCH ==Int CUR_EPOCH
    andBool #inCurDynasty(START_DYN, END_DYN, CUR_DYN)
    andBool #inPrevDynasty(START_DYN, END_DYN, CUR_DYN)
    // if self.expected_source_epoch == source_epoch
    andBool S_EPOCH ==Int EXPECTED_SOURCE_EPOCH
    // proc_reward
    andBool REWARD  ==Int ((VDEPOSIT *Int REWARD_FACTOR) /Int 10000000000) /Int 10000000000
    andBool END_DYN <Int DEFAULT_END_DYN
    andBool 0  <Int (REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000
    andBool CASPER_ACCT_ID =/=Int COINBASE_ACCT_ID
    // if (current_dynasty_votes >= self.total_curdyn_deposits * 2 / 3 and previous_dynasty_votes >= self.total_prevdyn_deposits * 2 / 3)
    andBool #isJustified(CUR_DYN_VOTES +Int VDEPOSIT, TOTAL_CUR_DYN_DEPOSITS, PREV_DYN_VOTES +Int VDEPOSIT, TOTAL_PREV_DYN_DEPOSITS)
    // if target_epoch == source_epoch + 1
    andBool T_EPOCH ==Int S_EPOCH +Int 1
ensures:
attribute:

[delete_validator]
comment: 
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("delete_validator", #int128(VINDEX))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: GCAP => GCAP -Int 121213
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _ => _
coinbase: _
activeAccounts: SetItem(CASPER_ACCT_ID) _:Set
casperBalance: CASPER_BAL
storage:
    // self.validators[validator_index].deposit
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {DEPOSIT}) |-> (VDEPOSIT => 0))
    // self.validators[validator_index].addr
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {ADDR}) |-> (VADDR => 0))
    // self.validators[validator_index].end_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {END_DYNASTY}) |-> (END_DYN => 0))
    // self.validators[validator_index].start_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {START_DYNASTY}) |-> (START_DYN => 0))
    // self.validators[validator_index].withdrawal_addr
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {WITHDRAWAL_ADDR}) |-> (VWITHDRAWALADDR => 0))
    // self.validator_indexes[self.validators[validator_index].withdrawal_addr]
    (#hashedLocation({COMPILER}, {VALIDATOR_INDEXES}, VWITHDRAWALADDR) |-> (VAL_IDX => 0))
accounts: 
requires:
    // Type constraint
    andBool 0  <Int VINDEX          andBool VINDEX          <=Int maxSInt128
    andBool 0 <=Int CASPER_BAL      andBool CASPER_BAL      <=Int maxUInt256
    andBool 0 <=Int VDEPOSIT        andBool VDEPOSIT        <=Int maxDecimal
    andBool 0 <=Int VADDR           andBool VADDR           <=Int maxUInt160
    andBool 0 <=Int END_DYN         andBool END_DYN         <=Int maxSInt128
    andBool 0 <=Int START_DYN       andBool START_DYN       <=Int maxSInt128
    andBool 0 <=Int VWITHDRAWALADDR andBool VWITHDRAWALADDR <=Int maxUInt160
    andBool 0 <=Int VAL_IDX         andBool VAL_IDX         <=Int maxSInt128
    andBool 0 <=Int CASPER_BAL      andBool CASPER_BAL      <=Int maxUInt256
    // Path condition
    andBool CALLER_ID ==Int CASPER_ACCT_ID
    // Call depth
    andBool 0 <=Int CD andBool CD <Int 1024
    // Gas
    andBool GCAP >=Int 121213
ensures:
attribute:

[increment_dynasty]
comment:
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("increment_dynasty", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 200000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _ => _
coinbase: _
activeAccounts: SetItem(CASPER_ACCT_ID) _:Set
casperBalance: _
storage:
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> EPOCH)
accounts:
requires:
    andBool #range(0 <= CD < 1024)
    andBool #rangeSInt(128, EPOCH)
    andBool EPOCH >=Int 0

    andBool CALLER_ID ==Int CASPER_ACCT_ID
ensures:
attribute:

[increment_dynasty-is_finalized]
+storage:
    // self.votes[epoch - 2].is_finalized : bool
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 2) {IS_FINALIZED}) |-> 1)
    // self.dynasty : int128
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> (DYNASTY => DYNASTY +Int 1))
    //self.total_prevdyn_deposits : decimal = self.total_curdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> (_ => TOTAL_CURDYN_DEPOSITS))
    //self.total_curdyn_deposits : decimal += self.dynasty_wei_delta[self.dynasty]
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)
                                 |-> (TOTAL_CURDYN_DEPOSITS => TOTAL_CURDYN_DEPOSITS +Int DYNASTY_WEI_DELTA))
    //self.dynasty_wei_delta[self.dynasty] : decimal
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, DYNASTY +Int 1)  |-> DYNASTY_WEI_DELTA)
    //self.dynasty_start_epoch[self.dynasty] :int128 = epoch
    (#hashedLocation({COMPILER}, {DYNASTY_START_EPOCH}, DYNASTY +Int 1)  |-> (_ => EPOCH))
    //self.dynasty_in_epoch[epoch] : int128 = self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY_IN_EPOCH}, EPOCH)  |-> (_ => DYNASTY +Int 1))
+requires:
    andBool EPOCH >=Int 2
    andBool #rangeSInt(128, DYNASTY)
    andBool #range(0 <= DYNASTY < maxSInt128)
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool 0 <=Int TOTAL_CURDYN_DEPOSITS
    andBool #range(0 <= TOTAL_CURDYN_DEPOSITS +Int DYNASTY_WEI_DELTA <= maxDecimal)
    andBool #rangeSFixed(128, 10, DYNASTY_WEI_DELTA)

[increment_dynasty-not-is_finalized]
+storage:
    // self.votes[epoch - 2].is_finalized : bool
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 2) {IS_FINALIZED}) |-> 0)
    // self.dynasty : int128
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> DYNASTY)
    //self.dynasty_in_epoch[epoch] : int128 = self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY_IN_EPOCH}, EPOCH)  |-> (_ => DYNASTY))
+requires:
    andBool EPOCH >=Int 2
    andBool #rangeSInt(128, DYNASTY)

[increment_dynasty-is_finalized-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (1 => 0))
    //self.expected_source_epoch : int128 = epoch - 1
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> (_ => EPOCH -Int 1))
    _:Map

[increment_dynasty-is_finalized-not-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> 0)
    _:Map

[increment_dynasty-not-is_finalized-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (1 => 0))
    //self.expected_source_epoch : int128 = epoch - 1
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> (_ => EPOCH -Int 1))
    _:Map

[increment_dynasty-not-is_finalized-not-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> 0)
    _:Map

[pgm]
compiler: "Vyper"
; self.validators
validators: 0
addr: 0
deposit: 1
end_dynasty: 2
start_dynasty: 3
withdrawal_addr: 4
; self.checkpoint_hashes
checkpoint_hashes: 1
; self.validator_indexes
validator_indexes: 3
; self.dynasty
dynasty: 4
; self.dynasty_wei_delta
dynasty_wei_delta: 5
; self.total_curdyn_deposits
total_curdyn_deposits: 6
; self.total_prevdyn_deposits
total_prevdyn_deposits: 7
; self.dynasty_in_epoch
dynasty_start_epoch: 8
; self.dynasty_in_epoch
dynasty_in_epoch: 9
; self.votes
votes: 10
cur_dyn_votes: 0
is_finalized: 1
is_justified: 2
prev_dyn_votes: 3
vote_bitmap: 4
; self.main_hash_justified
main_hash_justified: 11
; self.deposit_scale_factor
deposit_scale_factor: 12
; self.current_epoch
current_epoch: 15
; self.last_finalized_epoch
last_finalized_epoch: 16
; self.last_justified_epoch
last_justified_epoch: 17
; self.reward_factor
reward_factor: 18
; self.expected_source_epoch
expected_source_epoch: 19
; self.EPOCH_LENGTH
EPOCH_LENGTH: 21
; self.DEFAULT_END_DYNASTY
DEFAULT_END_DYNASTY: 30
code: "0x600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052638ed137b060005114156101c05734156100ac57600080fd5b600060a051600f54600c60c052602060c020015460065481810281198383830514176100d757600080fd5b6402540be4008105905090509050806080519013585780919012156100fb57600080fd5b1215610161576402540be4006402540be3ff60a051600f54600c60c052602060c0200154600654818102811983838305141761013657600080fd5b6402540be40081059050905090508060805190135857809190121561015a57600080fd5b03056101b6565b6402540be40060a051600f54600c60c052602060c0200154600654818102811983838305141761019057600080fd5b6402540be4008105905090509050806080519013585780919012156101b457600080fd5b055b60005260206000f3005b"
